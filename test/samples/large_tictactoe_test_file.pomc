u2[3] upper; // line 1
u2[3] middle; // line 2
u2[3] lower; // line 3
u2 final_winner; // line 4

/*   // line 6
    0 = non assigned // line 7
    1 = circle (player 1) // line 8
    2 = cross (player 2) // line 9
    Initial Condition:  // line 10
    |   | O |   | // line 11
    | O | X | X | // line 12
    |   | O |   | // line 13
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 14
*/  // line 15

main (){ // line 17
    u2 row_choice, column_choice; // line 18
    upper[0u2] = 0u2; // line 19
	upper[1u2] = 1u2; // line 20
	upper[2u2] = 0u2; // line 21
    middle[0u2] = 1u2; // line 22
	middle[1u2] = 2u2; // line 23
	middle[2u2] = 2u2; // line 24
    lower[0u2] = 0u2; // line 25
	lower[1u2] = 1u2; // line 26
	lower[2u2] = 0u2; // line 27

    final_winner = 0u2; // line 29
    query sampleAction(2u2, row_choice, column_choice); // line 30

} // line 32

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 34
    bool another_turn; // line 35
    u2 other_player; // line 36
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 37
    
    // sample a choice from the priori // line 39
    query action_priori(current_player, row_choice, column_choice); // line 40
    
    // is there a final_winner or is the grid filled? // line 42
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 43
    winning_condition(); // line 44

    // if nobody has won and there is another turn to play... // line 46
    if (final_winner == 0u2 && another_turn) {     // line 47
        // passing the turn // line 48
        if (current_player == 1u2) { // line 49
            other_player = 2u2; // line 50
        } else { // line 51
            other_player = 1u2; // line 52
        } // line 53
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 54

    } else {} // line 56

    // observing according to the utility of the outcome // line 58
    expected_utility(current_player); // line 59

    // returning row_choice and column_choice - the choice of the player // line 61
} // line 62


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 65
    u2 sampled_row_choice, sampled_column_choice; // line 66

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 68
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 69

    // observe that the choice is feasible, and update the grid // line 71
    if (sampled_row_choice == 0u2) { // line 72
        observe upper[sampled_column_choice] == 0u2; // line 73
        upper[sampled_column_choice] = current_player; // line 74
    } else { // line 75
        if (sampled_row_choice == 1u2) { // line 76
            observe middle[sampled_column_choice] == 0u2; // line 77
            middle[sampled_column_choice] = current_player; // line 78
        } else { // line 79
            observe lower[sampled_column_choice] == 0u2; // line 80
            lower[sampled_column_choice] = current_player; // line 81
        } // line 82
    } // line 83
    row_choice = sampled_row_choice; // line 84
    column_choice = sampled_column_choice; // line 85
} // line 86

expected_utility(u2 current_player) { // line 88
    bool coin_flip; // line 89
    u4 utility; // line 90

    if (final_winner == current_player) { // line 92
        utility = 10u4; // line 93
    } else { // line 94
        if (final_winner == 0u2) { // line 95
        utility = 5u4; // line 96
        } else { // line 97
            utility = 1u4; // line 98
        } // line 99
    } // line 100

    // outcome should range from 0 to 10 // line 102
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 103
    observe coin_flip; // line 104
} // line 105

winning_condition() { // line 107
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 108
        final_winner = upper[0u2]; // line 109
    } else { // line 110
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 111
            final_winner = middle[0u2]; // line 112
        } else { // line 113
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 114
                final_winner = lower[0u2]; // line 115
            } else { // line 116
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 117
                    final_winner = upper[0u2]; // line 118
                } else { // line 119
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 120
                        final_winner = upper[1u2]; // line 121
                    } else { // line 122
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 123
                            final_winner = upper[2u2]; // line 124
                        } else { // line 125
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 126
                                final_winner = upper[0u2]; // line 127
                            } else { // line 128
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 129
                                    final_winner = upper[2u2]; // line 130
                                } else { // line 131
                                    final_winner = 0u2; // line 132
                                } // line 133
                            } // line 134
                        } // line 135
                    } // line 136
                } // line 137
            } // line 138
        } // line 139
    } // line 140
} // line 141
/*   // line 147
    0 = non assigned // line 148
    1 = circle (player 1) // line 149
    2 = cross (player 2) // line 150
    Initial Condition:  // line 151
    |   | O |   | // line 152
    | O | X | X | // line 153
    |   | O |   | // line 154
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 155
*/  // line 156

main (){ // line 158
    u2 row_choice, column_choice; // line 159
    upper[0u2] = 0u2; // line 160
	upper[1u2] = 1u2; // line 161
	upper[2u2] = 0u2; // line 162
    middle[0u2] = 1u2; // line 163
	middle[1u2] = 2u2; // line 164
	middle[2u2] = 2u2; // line 165
    lower[0u2] = 0u2; // line 166
	lower[1u2] = 1u2; // line 167
	lower[2u2] = 0u2; // line 168

    final_winner = 0u2; // line 170
    query sampleAction(2u2, row_choice, column_choice); // line 171

} // line 173

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 175
    bool another_turn; // line 176
    u2 other_player; // line 177
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 178
    
    // sample a choice from the priori // line 180
    query action_priori(current_player, row_choice, column_choice); // line 181
    
    // is there a final_winner or is the grid filled? // line 183
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 184
    winning_condition(); // line 185

    // if nobody has won and there is another turn to play... // line 187
    if (final_winner == 0u2 && another_turn) {     // line 188
        // passing the turn // line 189
        if (current_player == 1u2) { // line 190
            other_player = 2u2; // line 191
        } else { // line 192
            other_player = 1u2; // line 193
        } // line 194
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 195

    } else {} // line 197

    // observing according to the utility of the outcome // line 199
    expected_utility(current_player); // line 200

    // returning row_choice and column_choice - the choice of the player // line 202
} // line 203


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 206
    u2 sampled_row_choice, sampled_column_choice; // line 207

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 209
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 210

    // observe that the choice is feasible, and update the grid // line 212
    if (sampled_row_choice == 0u2) { // line 213
        observe upper[sampled_column_choice] == 0u2; // line 214
        upper[sampled_column_choice] = current_player; // line 215
    } else { // line 216
        if (sampled_row_choice == 1u2) { // line 217
            observe middle[sampled_column_choice] == 0u2; // line 218
            middle[sampled_column_choice] = current_player; // line 219
        } else { // line 220
            observe lower[sampled_column_choice] == 0u2; // line 221
            lower[sampled_column_choice] = current_player; // line 222
        } // line 223
    } // line 224
    row_choice = sampled_row_choice; // line 225
    column_choice = sampled_column_choice; // line 226
} // line 227

expected_utility(u2 current_player) { // line 229
    bool coin_flip; // line 230
    u4 utility; // line 231

    if (final_winner == current_player) { // line 233
        utility = 10u4; // line 234
    } else { // line 235
        if (final_winner == 0u2) { // line 236
        utility = 5u4; // line 237
        } else { // line 238
            utility = 1u4; // line 239
        } // line 240
    } // line 241

    // outcome should range from 0 to 10 // line 243
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 244
    observe coin_flip; // line 245
} // line 246

winning_condition() { // line 248
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 249
        final_winner = upper[0u2]; // line 250
    } else { // line 251
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 252
            final_winner = middle[0u2]; // line 253
        } else { // line 254
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 255
                final_winner = lower[0u2]; // line 256
            } else { // line 257
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 258
                    final_winner = upper[0u2]; // line 259
                } else { // line 260
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 261
                        final_winner = upper[1u2]; // line 262
                    } else { // line 263
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 264
                            final_winner = upper[2u2]; // line 265
                        } else { // line 266
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 267
                                final_winner = upper[0u2]; // line 268
                            } else { // line 269
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 270
                                    final_winner = upper[2u2]; // line 271
                                } else { // line 272
                                    final_winner = 0u2; // line 273
                                } // line 274
                            } // line 275
                        } // line 276
                    } // line 277
                } // line 278
            } // line 279
        } // line 280
    } // line 281
} // line 282

/*   // line 288
    0 = non assigned // line 289
    1 = circle (player 1) // line 290
    2 = cross (player 2) // line 291
    Initial Condition:  // line 292
    |   | O |   | // line 293
    | O | X | X | // line 294
    |   | O |   | // line 295
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 296
*/  // line 297

main (){ // line 299
    u2 row_choice, column_choice; // line 300
    upper[0u2] = 0u2; // line 301
	upper[1u2] = 1u2; // line 302
	upper[2u2] = 0u2; // line 303
    middle[0u2] = 1u2; // line 304
	middle[1u2] = 2u2; // line 305
	middle[2u2] = 2u2; // line 306
    lower[0u2] = 0u2; // line 307
	lower[1u2] = 1u2; // line 308
	lower[2u2] = 0u2; // line 309

    final_winner = 0u2; // line 311
    query sampleAction(2u2, row_choice, column_choice); // line 312

} // line 314

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 316
    bool another_turn; // line 317
    u2 other_player; // line 318
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 319
    
    // sample a choice from the priori // line 321
    query action_priori(current_player, row_choice, column_choice); // line 322
    
    // is there a final_winner or is the grid filled? // line 324
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 325
    winning_condition(); // line 326

    // if nobody has won and there is another turn to play... // line 328
    if (final_winner == 0u2 && another_turn) {     // line 329
        // passing the turn // line 330
        if (current_player == 1u2) { // line 331
            other_player = 2u2; // line 332
        } else { // line 333
            other_player = 1u2; // line 334
        } // line 335
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 336

    } else {} // line 338

    // observing according to the utility of the outcome // line 340
    expected_utility(current_player); // line 341

    // returning row_choice and column_choice - the choice of the player // line 343
} // line 344


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 347
    u2 sampled_row_choice, sampled_column_choice; // line 348

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 350
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 351

    // observe that the choice is feasible, and update the grid // line 353
    if (sampled_row_choice == 0u2) { // line 354
        observe upper[sampled_column_choice] == 0u2; // line 355
        upper[sampled_column_choice] = current_player; // line 356
    } else { // line 357
        if (sampled_row_choice == 1u2) { // line 358
            observe middle[sampled_column_choice] == 0u2; // line 359
            middle[sampled_column_choice] = current_player; // line 360
        } else { // line 361
            observe lower[sampled_column_choice] == 0u2; // line 362
            lower[sampled_column_choice] = current_player; // line 363
        } // line 364
    } // line 365
    row_choice = sampled_row_choice; // line 366
    column_choice = sampled_column_choice; // line 367
} // line 368

expected_utility(u2 current_player) { // line 370
    bool coin_flip; // line 371
    u4 utility; // line 372

    if (final_winner == current_player) { // line 374
        utility = 10u4; // line 375
    } else { // line 376
        if (final_winner == 0u2) { // line 377
        utility = 5u4; // line 378
        } else { // line 379
            utility = 1u4; // line 380
        } // line 381
    } // line 382

    // outcome should range from 0 to 10 // line 384
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 385
    observe coin_flip; // line 386
} // line 387

winning_condition() { // line 389
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 390
        final_winner = upper[0u2]; // line 391
    } else { // line 392
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 393
            final_winner = middle[0u2]; // line 394
        } else { // line 395
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 396
                final_winner = lower[0u2]; // line 397
            } else { // line 398
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 399
                    final_winner = upper[0u2]; // line 400
                } else { // line 401
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 402
                        final_winner = upper[1u2]; // line 403
                    } else { // line 404
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 405
                            final_winner = upper[2u2]; // line 406
                        } else { // line 407
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 408
                                final_winner = upper[0u2]; // line 409
                            } else { // line 410
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 411
                                    final_winner = upper[2u2]; // line 412
                                } else { // line 413
                                    final_winner = 0u2; // line 414
                                } // line 415
                            } // line 416
                        } // line 417
                    } // line 418
                } // line 419
            } // line 420
        } // line 421
    } // line 422
} // line 423

/*   // line 429
    0 = non assigned // line 430
    1 = circle (player 1) // line 431
    2 = cross (player 2) // line 432
    Initial Condition:  // line 433
    |   | O |   | // line 434
    | O | X | X | // line 435
    |   | O |   | // line 436
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 437
*/  // line 438

main (){ // line 440
    u2 row_choice, column_choice; // line 441
    upper[0u2] = 0u2; // line 442
	upper[1u2] = 1u2; // line 443
	upper[2u2] = 0u2; // line 444
    middle[0u2] = 1u2; // line 445
	middle[1u2] = 2u2; // line 446
	middle[2u2] = 2u2; // line 447
    lower[0u2] = 0u2; // line 448
	lower[1u2] = 1u2; // line 449
	lower[2u2] = 0u2; // line 450

    final_winner = 0u2; // line 452
    query sampleAction(2u2, row_choice, column_choice); // line 453

} // line 455

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 457
    bool another_turn; // line 458
    u2 other_player; // line 459
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 460
    
    // sample a choice from the priori // line 462
    query action_priori(current_player, row_choice, column_choice); // line 463
    
    // is there a final_winner or is the grid filled? // line 465
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 466
    winning_condition(); // line 467

    // if nobody has won and there is another turn to play... // line 469
    if (final_winner == 0u2 && another_turn) {     // line 470
        // passing the turn // line 471
        if (current_player == 1u2) { // line 472
            other_player = 2u2; // line 473
        } else { // line 474
            other_player = 1u2; // line 475
        } // line 476
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 477

    } else {} // line 479

    // observing according to the utility of the outcome // line 481
    expected_utility(current_player); // line 482

    // returning row_choice and column_choice - the choice of the player // line 484
} // line 485


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 488
    u2 sampled_row_choice, sampled_column_choice; // line 489

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 491
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 492

    // observe that the choice is feasible, and update the grid // line 494
    if (sampled_row_choice == 0u2) { // line 495
        observe upper[sampled_column_choice] == 0u2; // line 496
        upper[sampled_column_choice] = current_player; // line 497
    } else { // line 498
        if (sampled_row_choice == 1u2) { // line 499
            observe middle[sampled_column_choice] == 0u2; // line 500
            middle[sampled_column_choice] = current_player; // line 501
        } else { // line 502
            observe lower[sampled_column_choice] == 0u2; // line 503
            lower[sampled_column_choice] = current_player; // line 504
        } // line 505
    } // line 506
    row_choice = sampled_row_choice; // line 507
    column_choice = sampled_column_choice; // line 508
} // line 509

expected_utility(u2 current_player) { // line 511
    bool coin_flip; // line 512
    u4 utility; // line 513

    if (final_winner == current_player) { // line 515
        utility = 10u4; // line 516
    } else { // line 517
        if (final_winner == 0u2) { // line 518
        utility = 5u4; // line 519
        } else { // line 520
            utility = 1u4; // line 521
        } // line 522
    } // line 523

    // outcome should range from 0 to 10 // line 525
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 526
    observe coin_flip; // line 527
} // line 528

winning_condition() { // line 530
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 531
        final_winner = upper[0u2]; // line 532
    } else { // line 533
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 534
            final_winner = middle[0u2]; // line 535
        } else { // line 536
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 537
                final_winner = lower[0u2]; // line 538
            } else { // line 539
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 540
                    final_winner = upper[0u2]; // line 541
                } else { // line 542
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 543
                        final_winner = upper[1u2]; // line 544
                    } else { // line 545
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 546
                            final_winner = upper[2u2]; // line 547
                        } else { // line 548
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 549
                                final_winner = upper[0u2]; // line 550
                            } else { // line 551
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 552
                                    final_winner = upper[2u2]; // line 553
                                } else { // line 554
                                    final_winner = 0u2; // line 555
                                } // line 556
                            } // line 557
                        } // line 558
                    } // line 559
                } // line 560
            } // line 561
        } // line 562
    } // line 563
} // line 564

/*   // line 570
    0 = non assigned // line 571
    1 = circle (player 1) // line 572
    2 = cross (player 2) // line 573
    Initial Condition:  // line 574
    |   | O |   | // line 575
    | O | X | X | // line 576
    |   | O |   | // line 577
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 578
*/  // line 579

main (){ // line 581
    u2 row_choice, column_choice; // line 582
    upper[0u2] = 0u2; // line 583
	upper[1u2] = 1u2; // line 584
	upper[2u2] = 0u2; // line 585
    middle[0u2] = 1u2; // line 586
	middle[1u2] = 2u2; // line 587
	middle[2u2] = 2u2; // line 588
    lower[0u2] = 0u2; // line 589
	lower[1u2] = 1u2; // line 590
	lower[2u2] = 0u2; // line 591

    final_winner = 0u2; // line 593
    query sampleAction(2u2, row_choice, column_choice); // line 594

} // line 596

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 598
    bool another_turn; // line 599
    u2 other_player; // line 600
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 601
    
    // sample a choice from the priori // line 603
    query action_priori(current_player, row_choice, column_choice); // line 604
    
    // is there a final_winner or is the grid filled? // line 606
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 607
    winning_condition(); // line 608

    // if nobody has won and there is another turn to play... // line 610
    if (final_winner == 0u2 && another_turn) {     // line 611
        // passing the turn // line 612
        if (current_player == 1u2) { // line 613
            other_player = 2u2; // line 614
        } else { // line 615
            other_player = 1u2; // line 616
        } // line 617
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 618

    } else {} // line 620

    // observing according to the utility of the outcome // line 622
    expected_utility(current_player); // line 623

    // returning row_choice and column_choice - the choice of the player // line 625
} // line 626


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 629
    u2 sampled_row_choice, sampled_column_choice; // line 630

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 632
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 633

    // observe that the choice is feasible, and update the grid // line 635
    if (sampled_row_choice == 0u2) { // line 636
        observe upper[sampled_column_choice] == 0u2; // line 637
        upper[sampled_column_choice] = current_player; // line 638
    } else { // line 639
        if (sampled_row_choice == 1u2) { // line 640
            observe middle[sampled_column_choice] == 0u2; // line 641
            middle[sampled_column_choice] = current_player; // line 642
        } else { // line 643
            observe lower[sampled_column_choice] == 0u2; // line 644
            lower[sampled_column_choice] = current_player; // line 645
        } // line 646
    } // line 647
    row_choice = sampled_row_choice; // line 648
    column_choice = sampled_column_choice; // line 649
} // line 650

expected_utility(u2 current_player) { // line 652
    bool coin_flip; // line 653
    u4 utility; // line 654

    if (final_winner == current_player) { // line 656
        utility = 10u4; // line 657
    } else { // line 658
        if (final_winner == 0u2) { // line 659
        utility = 5u4; // line 660
        } else { // line 661
            utility = 1u4; // line 662
        } // line 663
    } // line 664

    // outcome should range from 0 to 10 // line 666
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 667
    observe coin_flip; // line 668
} // line 669

winning_condition() { // line 671
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 672
        final_winner = upper[0u2]; // line 673
    } else { // line 674
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 675
            final_winner = middle[0u2]; // line 676
        } else { // line 677
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 678
                final_winner = lower[0u2]; // line 679
            } else { // line 680
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 681
                    final_winner = upper[0u2]; // line 682
                } else { // line 683
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 684
                        final_winner = upper[1u2]; // line 685
                    } else { // line 686
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 687
                            final_winner = upper[2u2]; // line 688
                        } else { // line 689
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 690
                                final_winner = upper[0u2]; // line 691
                            } else { // line 692
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 693
                                    final_winner = upper[2u2]; // line 694
                                } else { // line 695
                                    final_winner = 0u2; // line 696
                                } // line 697
                            } // line 698
                        } // line 699
                    } // line 700
                } // line 701
            } // line 702
        } // line 703
    } // line 704
} // line 705

/*   // line 711
    0 = non assigned // line 712
    1 = circle (player 1) // line 713
    2 = cross (player 2) // line 714
    Initial Condition:  // line 715
    |   | O |   | // line 716
    | O | X | X | // line 717
    |   | O |   | // line 718
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 719
*/  // line 720

main (){ // line 722
    u2 row_choice, column_choice; // line 723
    upper[0u2] = 0u2; // line 724
	upper[1u2] = 1u2; // line 725
	upper[2u2] = 0u2; // line 726
    middle[0u2] = 1u2; // line 727
	middle[1u2] = 2u2; // line 728
	middle[2u2] = 2u2; // line 729
    lower[0u2] = 0u2; // line 730
	lower[1u2] = 1u2; // line 731
	lower[2u2] = 0u2; // line 732

    final_winner = 0u2; // line 734
    query sampleAction(2u2, row_choice, column_choice); // line 735

} // line 737

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 739
    bool another_turn; // line 740
    u2 other_player; // line 741
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 742
    
    // sample a choice from the priori // line 744
    query action_priori(current_player, row_choice, column_choice); // line 745
    
    // is there a final_winner or is the grid filled? // line 747
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 748
    winning_condition(); // line 749

    // if nobody has won and there is another turn to play... // line 751
    if (final_winner == 0u2 && another_turn) {     // line 752
        // passing the turn // line 753
        if (current_player == 1u2) { // line 754
            other_player = 2u2; // line 755
        } else { // line 756
            other_player = 1u2; // line 757
        } // line 758
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 759

    } else {} // line 761

    // observing according to the utility of the outcome // line 763
    expected_utility(current_player); // line 764

    // returning row_choice and column_choice - the choice of the player // line 766
} // line 767


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 770
    u2 sampled_row_choice, sampled_column_choice; // line 771

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 773
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 774

    // observe that the choice is feasible, and update the grid // line 776
    if (sampled_row_choice == 0u2) { // line 777
        observe upper[sampled_column_choice] == 0u2; // line 778
        upper[sampled_column_choice] = current_player; // line 779
    } else { // line 780
        if (sampled_row_choice == 1u2) { // line 781
            observe middle[sampled_column_choice] == 0u2; // line 782
            middle[sampled_column_choice] = current_player; // line 783
        } else { // line 784
            observe lower[sampled_column_choice] == 0u2; // line 785
            lower[sampled_column_choice] = current_player; // line 786
        } // line 787
    } // line 788
    row_choice = sampled_row_choice; // line 789
    column_choice = sampled_column_choice; // line 790
} // line 791

expected_utility(u2 current_player) { // line 793
    bool coin_flip; // line 794
    u4 utility; // line 795

    if (final_winner == current_player) { // line 797
        utility = 10u4; // line 798
    } else { // line 799
        if (final_winner == 0u2) { // line 800
        utility = 5u4; // line 801
        } else { // line 802
            utility = 1u4; // line 803
        } // line 804
    } // line 805

    // outcome should range from 0 to 10 // line 807
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 808
    observe coin_flip; // line 809
} // line 810

winning_condition() { // line 812
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 813
        final_winner = upper[0u2]; // line 814
    } else { // line 815
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 816
            final_winner = middle[0u2]; // line 817
        } else { // line 818
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 819
                final_winner = lower[0u2]; // line 820
            } else { // line 821
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 822
                    final_winner = upper[0u2]; // line 823
                } else { // line 824
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 825
                        final_winner = upper[1u2]; // line 826
                    } else { // line 827
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 828
                            final_winner = upper[2u2]; // line 829
                        } else { // line 830
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 831
                                final_winner = upper[0u2]; // line 832
                            } else { // line 833
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 834
                                    final_winner = upper[2u2]; // line 835
                                } else { // line 836
                                    final_winner = 0u2; // line 837
                                } // line 838
                            } // line 839
                        } // line 840
                    } // line 841
                } // line 842
            } // line 843
        } // line 844
    } // line 845
} // line 846

/*   // line 852
    0 = non assigned // line 853
    1 = circle (player 1) // line 854
    2 = cross (player 2) // line 855
    Initial Condition:  // line 856
    |   | O |   | // line 857
    | O | X | X | // line 858
    |   | O |   | // line 859
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 860
*/  // line 861

main (){ // line 863
    u2 row_choice, column_choice; // line 864
    upper[0u2] = 0u2; // line 865
	upper[1u2] = 1u2; // line 866
	upper[2u2] = 0u2; // line 867
    middle[0u2] = 1u2; // line 868
	middle[1u2] = 2u2; // line 869
	middle[2u2] = 2u2; // line 870
    lower[0u2] = 0u2; // line 871
	lower[1u2] = 1u2; // line 872
	lower[2u2] = 0u2; // line 873

    final_winner = 0u2; // line 875
    query sampleAction(2u2, row_choice, column_choice); // line 876

} // line 878

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 880
    bool another_turn; // line 881
    u2 other_player; // line 882
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 883
    
    // sample a choice from the priori // line 885
    query action_priori(current_player, row_choice, column_choice); // line 886
    
    // is there a final_winner or is the grid filled? // line 888
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 889
    winning_condition(); // line 890

    // if nobody has won and there is another turn to play... // line 892
    if (final_winner == 0u2 && another_turn) {     // line 893
        // passing the turn // line 894
        if (current_player == 1u2) { // line 895
            other_player = 2u2; // line 896
        } else { // line 897
            other_player = 1u2; // line 898
        } // line 899
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 900

    } else {} // line 902

    // observing according to the utility of the outcome // line 904
    expected_utility(current_player); // line 905

    // returning row_choice and column_choice - the choice of the player // line 907
} // line 908


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 911
    u2 sampled_row_choice, sampled_column_choice; // line 912

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 914
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 915

    // observe that the choice is feasible, and update the grid // line 917
    if (sampled_row_choice == 0u2) { // line 918
        observe upper[sampled_column_choice] == 0u2; // line 919
        upper[sampled_column_choice] = current_player; // line 920
    } else { // line 921
        if (sampled_row_choice == 1u2) { // line 922
            observe middle[sampled_column_choice] == 0u2; // line 923
            middle[sampled_column_choice] = current_player; // line 924
        } else { // line 925
            observe lower[sampled_column_choice] == 0u2; // line 926
            lower[sampled_column_choice] = current_player; // line 927
        } // line 928
    } // line 929
    row_choice = sampled_row_choice; // line 930
    column_choice = sampled_column_choice; // line 931
} // line 932

expected_utility(u2 current_player) { // line 934
    bool coin_flip; // line 935
    u4 utility; // line 936

    if (final_winner == current_player) { // line 938
        utility = 10u4; // line 939
    } else { // line 940
        if (final_winner == 0u2) { // line 941
        utility = 5u4; // line 942
        } else { // line 943
            utility = 1u4; // line 944
        } // line 945
    } // line 946

    // outcome should range from 0 to 10 // line 948
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 949
    observe coin_flip; // line 950
} // line 951

winning_condition() { // line 953
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 954
        final_winner = upper[0u2]; // line 955
    } else { // line 956
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 957
            final_winner = middle[0u2]; // line 958
        } else { // line 959
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 960
                final_winner = lower[0u2]; // line 961
            } else { // line 962
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 963
                    final_winner = upper[0u2]; // line 964
                } else { // line 965
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 966
                        final_winner = upper[1u2]; // line 967
                    } else { // line 968
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 969
                            final_winner = upper[2u2]; // line 970
                        } else { // line 971
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 972
                                final_winner = upper[0u2]; // line 973
                            } else { // line 974
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 975
                                    final_winner = upper[2u2]; // line 976
                                } else { // line 977
                                    final_winner = 0u2; // line 978
                                } // line 979
                            } // line 980
                        } // line 981
                    } // line 982
                } // line 983
            } // line 984
        } // line 985
    } // line 986
} // line 987

/*   // line 993
    0 = non assigned // line 994
    1 = circle (player 1) // line 995
    2 = cross (player 2) // line 996
    Initial Condition:  // line 997
    |   | O |   | // line 998
    | O | X | X | // line 999
    |   | O |   | // line 1000
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1001
*/  // line 1002

main (){ // line 1004
    u2 row_choice, column_choice; // line 1005
    upper[0u2] = 0u2; // line 1006
	upper[1u2] = 1u2; // line 1007
	upper[2u2] = 0u2; // line 1008
    middle[0u2] = 1u2; // line 1009
	middle[1u2] = 2u2; // line 1010
	middle[2u2] = 2u2; // line 1011
    lower[0u2] = 0u2; // line 1012
	lower[1u2] = 1u2; // line 1013
	lower[2u2] = 0u2; // line 1014

    final_winner = 0u2; // line 1016
    query sampleAction(2u2, row_choice, column_choice); // line 1017

} // line 1019

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1021
    bool another_turn; // line 1022
    u2 other_player; // line 1023
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 1024
    
    // sample a choice from the priori // line 1026
    query action_priori(current_player, row_choice, column_choice); // line 1027
    
    // is there a final_winner or is the grid filled? // line 1029
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 1030
    winning_condition(); // line 1031

    // if nobody has won and there is another turn to play... // line 1033
    if (final_winner == 0u2 && another_turn) {     // line 1034
        // passing the turn // line 1035
        if (current_player == 1u2) { // line 1036
            other_player = 2u2; // line 1037
        } else { // line 1038
            other_player = 1u2; // line 1039
        } // line 1040
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 1041

    } else {} // line 1043

    // observing according to the utility of the outcome // line 1045
    expected_utility(current_player); // line 1046

    // returning row_choice and column_choice - the choice of the player // line 1048
} // line 1049


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1052
    u2 sampled_row_choice, sampled_column_choice; // line 1053

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1055
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1056

    // observe that the choice is feasible, and update the grid // line 1058
    if (sampled_row_choice == 0u2) { // line 1059
        observe upper[sampled_column_choice] == 0u2; // line 1060
        upper[sampled_column_choice] = current_player; // line 1061
    } else { // line 1062
        if (sampled_row_choice == 1u2) { // line 1063
            observe middle[sampled_column_choice] == 0u2; // line 1064
            middle[sampled_column_choice] = current_player; // line 1065
        } else { // line 1066
            observe lower[sampled_column_choice] == 0u2; // line 1067
            lower[sampled_column_choice] = current_player; // line 1068
        } // line 1069
    } // line 1070
    row_choice = sampled_row_choice; // line 1071
    column_choice = sampled_column_choice; // line 1072
} // line 1073

expected_utility(u2 current_player) { // line 1075
    bool coin_flip; // line 1076
    u4 utility; // line 1077

    if (final_winner == current_player) { // line 1079
        utility = 10u4; // line 1080
    } else { // line 1081
        if (final_winner == 0u2) { // line 1082
        utility = 5u4; // line 1083
        } else { // line 1084
            utility = 1u4; // line 1085
        } // line 1086
    } // line 1087

    // outcome should range from 0 to 10 // line 1089
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 1090
    observe coin_flip; // line 1091
} // line 1092

winning_condition() { // line 1094
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 1095
        final_winner = upper[0u2]; // line 1096
    } else { // line 1097
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 1098
            final_winner = middle[0u2]; // line 1099
        } else { // line 1100
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 1101
                final_winner = lower[0u2]; // line 1102
            } else { // line 1103
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 1104
                    final_winner = upper[0u2]; // line 1105
                } else { // line 1106
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 1107
                        final_winner = upper[1u2]; // line 1108
                    } else { // line 1109
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 1110
                            final_winner = upper[2u2]; // line 1111
                        } else { // line 1112
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 1113
                                final_winner = upper[0u2]; // line 1114
                            } else { // line 1115
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 1116
                                    final_winner = upper[2u2]; // line 1117
                                } else { // line 1118
                                    final_winner = 0u2; // line 1119
                                } // line 1120
                            } // line 1121
                        } // line 1122
                    } // line 1123
                } // line 1124
            } // line 1125
        } // line 1126
    } // line 1127
} // line 1128

/*   // line 1134
    0 = non assigned // line 1135
    1 = circle (player 1) // line 1136
    2 = cross (player 2) // line 1137
    Initial Condition:  // line 1138
    |   | O |   | // line 1139
    | O | X | X | // line 1140
    |   | O |   | // line 1141
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1142
*/  // line 1143

main (){ // line 1145
    u2 row_choice, column_choice; // line 1146
    upper[0u2] = 0u2; // line 1147
	upper[1u2] = 1u2; // line 1148
	upper[2u2] = 0u2; // line 1149
    middle[0u2] = 1u2; // line 1150
	middle[1u2] = 2u2; // line 1151
	middle[2u2] = 2u2; // line 1152
    lower[0u2] = 0u2; // line 1153
	lower[1u2] = 1u2; // line 1154
	lower[2u2] = 0u2; // line 1155

    final_winner = 0u2; // line 1157
    query sampleAction(2u2, row_choice, column_choice); // line 1158

} // line 1160

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1162
    bool another_turn; // line 1163
    u2 other_player; // line 1164
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 1165
    
    // sample a choice from the priori // line 1167
    query action_priori(current_player, row_choice, column_choice); // line 1168
    
    // is there a final_winner or is the grid filled? // line 1170
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 1171
    winning_condition(); // line 1172

    // if nobody has won and there is another turn to play... // line 1174
    if (final_winner == 0u2 && another_turn) {     // line 1175
        // passing the turn // line 1176
        if (current_player == 1u2) { // line 1177
            other_player = 2u2; // line 1178
        } else { // line 1179
            other_player = 1u2; // line 1180
        } // line 1181
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 1182

    } else {} // line 1184

    // observing according to the utility of the outcome // line 1186
    expected_utility(current_player); // line 1187

    // returning row_choice and column_choice - the choice of the player // line 1189
} // line 1190


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1193
    u2 sampled_row_choice, sampled_column_choice; // line 1194

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1196
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1197

    // observe that the choice is feasible, and update the grid // line 1199
    if (sampled_row_choice == 0u2) { // line 1200
        observe upper[sampled_column_choice] == 0u2; // line 1201
        upper[sampled_column_choice] = current_player; // line 1202
    } else { // line 1203
        if (sampled_row_choice == 1u2) { // line 1204
            observe middle[sampled_column_choice] == 0u2; // line 1205
            middle[sampled_column_choice] = current_player; // line 1206
        } else { // line 1207
            observe lower[sampled_column_choice] == 0u2; // line 1208
            lower[sampled_column_choice] = current_player; // line 1209
        } // line 1210
    } // line 1211
    row_choice = sampled_row_choice; // line 1212
    column_choice = sampled_column_choice; // line 1213
} // line 1214

expected_utility(u2 current_player) { // line 1216
    bool coin_flip; // line 1217
    u4 utility; // line 1218

    if (final_winner == current_player) { // line 1220
        utility = 10u4; // line 1221
    } else { // line 1222
        if (final_winner == 0u2) { // line 1223
        utility = 5u4; // line 1224
        } else { // line 1225
            utility = 1u4; // line 1226
        } // line 1227
    } // line 1228

    // outcome should range from 0 to 10 // line 1230
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 1231
    observe coin_flip; // line 1232
} // line 1233

winning_condition() { // line 1235
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 1236
        final_winner = upper[0u2]; // line 1237
    } else { // line 1238
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 1239
            final_winner = middle[0u2]; // line 1240
        } else { // line 1241
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 1242
                final_winner = lower[0u2]; // line 1243
            } else { // line 1244
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 1245
                    final_winner = upper[0u2]; // line 1246
                } else { // line 1247
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 1248
                        final_winner = upper[1u2]; // line 1249
                    } else { // line 1250
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 1251
                            final_winner = upper[2u2]; // line 1252
                        } else { // line 1253
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 1254
                                final_winner = upper[0u2]; // line 1255
                            } else { // line 1256
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 1257
                                    final_winner = upper[2u2]; // line 1258
                                } else { // line 1259
                                    final_winner = 0u2; // line 1260
                                } // line 1261
                            } // line 1262
                        } // line 1263
                    } // line 1264
                } // line 1265
            } // line 1266
        } // line 1267
    } // line 1268
} // line 1269

/*   // line 1275
    0 = non assigned // line 1276
    1 = circle (player 1) // line 1277
    2 = cross (player 2) // line 1278
    Initial Condition:  // line 1279
    |   | O |   | // line 1280
    | O | X | X | // line 1281
    |   | O |   | // line 1282
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1283
*/  // line 1284

main (){ // line 1286
    u2 row_choice, column_choice; // line 1287
    upper[0u2] = 0u2; // line 1288
	upper[1u2] = 1u2; // line 1289
	upper[2u2] = 0u2; // line 1290
    middle[0u2] = 1u2; // line 1291
	middle[1u2] = 2u2; // line 1292
	middle[2u2] = 2u2; // line 1293
    lower[0u2] = 0u2; // line 1294
	lower[1u2] = 1u2; // line 1295
	lower[2u2] = 0u2; // line 1296

    final_winner = 0u2; // line 1298
    query sampleAction(2u2, row_choice, column_choice); // line 1299

} // line 1301

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1303
    bool another_turn; // line 1304
    u2 other_player; // line 1305
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 1306
    
    // sample a choice from the priori // line 1308
    query action_priori(current_player, row_choice, column_choice); // line 1309
    
    // is there a final_winner or is the grid filled? // line 1311
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 1312
    winning_condition(); // line 1313

    // if nobody has won and there is another turn to play... // line 1315
    if (final_winner == 0u2 && another_turn) {     // line 1316
        // passing the turn // line 1317
        if (current_player == 1u2) { // line 1318
            other_player = 2u2; // line 1319
        } else { // line 1320
            other_player = 1u2; // line 1321
        } // line 1322
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 1323

    } else {} // line 1325

    // observing according to the utility of the outcome // line 1327
    expected_utility(current_player); // line 1328

    // returning row_choice and column_choice - the choice of the player // line 1330
} // line 1331


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1334
    u2 sampled_row_choice, sampled_column_choice; // line 1335

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1337
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1338

    // observe that the choice is feasible, and update the grid // line 1340
    if (sampled_row_choice == 0u2) { // line 1341
        observe upper[sampled_column_choice] == 0u2; // line 1342
        upper[sampled_column_choice] = current_player; // line 1343
    } else { // line 1344
        if (sampled_row_choice == 1u2) { // line 1345
            observe middle[sampled_column_choice] == 0u2; // line 1346
            middle[sampled_column_choice] = current_player; // line 1347
        } else { // line 1348
            observe lower[sampled_column_choice] == 0u2; // line 1349
            lower[sampled_column_choice] = current_player; // line 1350
        } // line 1351
    } // line 1352
    row_choice = sampled_row_choice; // line 1353
    column_choice = sampled_column_choice; // line 1354
} // line 1355

expected_utility(u2 current_player) { // line 1357
    bool coin_flip; // line 1358
    u4 utility; // line 1359

    if (final_winner == current_player) { // line 1361
        utility = 10u4; // line 1362
    } else { // line 1363
        if (final_winner == 0u2) { // line 1364
        utility = 5u4; // line 1365
        } else { // line 1366
            utility = 1u4; // line 1367
        } // line 1368
    } // line 1369

    // outcome should range from 0 to 10 // line 1371
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 1372
    observe coin_flip; // line 1373
} // line 1374

winning_condition() { // line 1376
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 1377
        final_winner = upper[0u2]; // line 1378
    } else { // line 1379
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 1380
            final_winner = middle[0u2]; // line 1381
        } else { // line 1382
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 1383
                final_winner = lower[0u2]; // line 1384
            } else { // line 1385
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 1386
                    final_winner = upper[0u2]; // line 1387
                } else { // line 1388
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 1389
                        final_winner = upper[1u2]; // line 1390
                    } else { // line 1391
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 1392
                            final_winner = upper[2u2]; // line 1393
                        } else { // line 1394
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 1395
                                final_winner = upper[0u2]; // line 1396
                            } else { // line 1397
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 1398
                                    final_winner = upper[2u2]; // line 1399
                                } else { // line 1400
                                    final_winner = 0u2; // line 1401
                                } // line 1402
                            } // line 1403
                        } // line 1404
                    } // line 1405
                } // line 1406
            } // line 1407
        } // line 1408
    } // line 1409
} // line 1410

/*   // line 1416
    0 = non assigned // line 1417
    1 = circle (player 1) // line 1418
    2 = cross (player 2) // line 1419
    Initial Condition:  // line 1420
    |   | O |   | // line 1421
    | O | X | X | // line 1422
    |   | O |   | // line 1423
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1424
*/  // line 1425

main (){ // line 1427
    u2 row_choice, column_choice; // line 1428
    upper[0u2] = 0u2; // line 1429
	upper[1u2] = 1u2; // line 1430
	upper[2u2] = 0u2; // line 1431
    middle[0u2] = 1u2; // line 1432
	middle[1u2] = 2u2; // line 1433
	middle[2u2] = 2u2; // line 1434
    lower[0u2] = 0u2; // line 1435
	lower[1u2] = 1u2; // line 1436
	lower[2u2] = 0u2; // line 1437

    final_winner = 0u2; // line 1439
    query sampleAction(2u2, row_choice, column_choice); // line 1440

} // line 1442

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1444
    bool another_turn; // line 1445
    u2 other_player; // line 1446
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 1447
    
    // sample a choice from the priori // line 1449
    query action_priori(current_player, row_choice, column_choice); // line 1450
    
    // is there a final_winner or is the grid filled? // line 1452
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 1453
    winning_condition(); // line 1454

    // if nobody has won and there is another turn to play... // line 1456
    if (final_winner == 0u2 && another_turn) {     // line 1457
        // passing the turn // line 1458
        if (current_player == 1u2) { // line 1459
            other_player = 2u2; // line 1460
        } else { // line 1461
            other_player = 1u2; // line 1462
        } // line 1463
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 1464

    } else {} // line 1466

    // observing according to the utility of the outcome // line 1468
    expected_utility(current_player); // line 1469

    // returning row_choice and column_choice - the choice of the player // line 1471
} // line 1472


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1475
    u2 sampled_row_choice, sampled_column_choice; // line 1476

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1478
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1479

    // observe that the choice is feasible, and update the grid // line 1481
    if (sampled_row_choice == 0u2) { // line 1482
        observe upper[sampled_column_choice] == 0u2; // line 1483
        upper[sampled_column_choice] = current_player; // line 1484
    } else { // line 1485
        if (sampled_row_choice == 1u2) { // line 1486
            observe middle[sampled_column_choice] == 0u2; // line 1487
            middle[sampled_column_choice] = current_player; // line 1488
        } else { // line 1489
            observe lower[sampled_column_choice] == 0u2; // line 1490
            lower[sampled_column_choice] = current_player; // line 1491
        } // line 1492
    } // line 1493
    row_choice = sampled_row_choice; // line 1494
    column_choice = sampled_column_choice; // line 1495
} // line 1496

expected_utility(u2 current_player) { // line 1498
    bool coin_flip; // line 1499
    u4 utility; // line 1500

    if (final_winner == current_player) { // line 1502
        utility = 10u4; // line 1503
    } else { // line 1504
        if (final_winner == 0u2) { // line 1505
        utility = 5u4; // line 1506
        } else { // line 1507
            utility = 1u4; // line 1508
        } // line 1509
    } // line 1510

    // outcome should range from 0 to 10 // line 1512
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 1513
    observe coin_flip; // line 1514
} // line 1515

winning_condition() { // line 1517
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 1518
        final_winner = upper[0u2]; // line 1519
    } else { // line 1520
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 1521
            final_winner = middle[0u2]; // line 1522
        } else { // line 1523
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 1524
                final_winner = lower[0u2]; // line 1525
            } else { // line 1526
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 1527
                    final_winner = upper[0u2]; // line 1528
                } else { // line 1529
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 1530
                        final_winner = upper[1u2]; // line 1531
                    } else { // line 1532
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 1533
                            final_winner = upper[2u2]; // line 1534
                        } else { // line 1535
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 1536
                                final_winner = upper[0u2]; // line 1537
                            } else { // line 1538
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 1539
                                    final_winner = upper[2u2]; // line 1540
                                } else { // line 1541
                                    final_winner = 0u2; // line 1542
                                } // line 1543
                            } // line 1544
                        } // line 1545
                    } // line 1546
                } // line 1547
            } // line 1548
        } // line 1549
    } // line 1550
} // line 1551

/*   // line 1557
    0 = non assigned // line 1558
    1 = circle (player 1) // line 1559
    2 = cross (player 2) // line 1560
    Initial Condition:  // line 1561
    |   | O |   | // line 1562
    | O | X | X | // line 1563
    |   | O |   | // line 1564
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1565
*/  // line 1566

main (){ // line 1568
    u2 row_choice, column_choice; // line 1569
    upper[0u2] = 0u2; // line 1570
	upper[1u2] = 1u2; // line 1571
	upper[2u2] = 0u2; // line 1572
    middle[0u2] = 1u2; // line 1573
	middle[1u2] = 2u2; // line 1574
	middle[2u2] = 2u2; // line 1575
    lower[0u2] = 0u2; // line 1576
	lower[1u2] = 1u2; // line 1577
	lower[2u2] = 0u2; // line 1578

    final_winner = 0u2; // line 1580
    query sampleAction(2u2, row_choice, column_choice); // line 1581

} // line 1583

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1585
    bool another_turn; // line 1586
    u2 other_player; // line 1587
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 1588
    
    // sample a choice from the priori // line 1590
    query action_priori(current_player, row_choice, column_choice); // line 1591
    
    // is there a final_winner or is the grid filled? // line 1593
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 1594
    winning_condition(); // line 1595

    // if nobody has won and there is another turn to play... // line 1597
    if (final_winner == 0u2 && another_turn) {     // line 1598
        // passing the turn // line 1599
        if (current_player == 1u2) { // line 1600
            other_player = 2u2; // line 1601
        } else { // line 1602
            other_player = 1u2; // line 1603
        } // line 1604
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 1605

    } else {} // line 1607

    // observing according to the utility of the outcome // line 1609
    expected_utility(current_player); // line 1610

    // returning row_choice and column_choice - the choice of the player // line 1612
} // line 1613


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1616
    u2 sampled_row_choice, sampled_column_choice; // line 1617

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1619
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1620

    // observe that the choice is feasible, and update the grid // line 1622
    if (sampled_row_choice == 0u2) { // line 1623
        observe upper[sampled_column_choice] == 0u2; // line 1624
        upper[sampled_column_choice] = current_player; // line 1625
    } else { // line 1626
        if (sampled_row_choice == 1u2) { // line 1627
            observe middle[sampled_column_choice] == 0u2; // line 1628
            middle[sampled_column_choice] = current_player; // line 1629
        } else { // line 1630
            observe lower[sampled_column_choice] == 0u2; // line 1631
            lower[sampled_column_choice] = current_player; // line 1632
        } // line 1633
    } // line 1634
    row_choice = sampled_row_choice; // line 1635
    column_choice = sampled_column_choice; // line 1636
} // line 1637

expected_utility(u2 current_player) { // line 1639
    bool coin_flip; // line 1640
    u4 utility; // line 1641

    if (final_winner == current_player) { // line 1643
        utility = 10u4; // line 1644
    } else { // line 1645
        if (final_winner == 0u2) { // line 1646
        utility = 5u4; // line 1647
        } else { // line 1648
            utility = 1u4; // line 1649
        } // line 1650
    } // line 1651

    // outcome should range from 0 to 10 // line 1653
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 1654
    observe coin_flip; // line 1655
} // line 1656

winning_condition() { // line 1658
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 1659
        final_winner = upper[0u2]; // line 1660
    } else { // line 1661
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 1662
            final_winner = middle[0u2]; // line 1663
        } else { // line 1664
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 1665
                final_winner = lower[0u2]; // line 1666
            } else { // line 1667
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 1668
                    final_winner = upper[0u2]; // line 1669
                } else { // line 1670
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 1671
                        final_winner = upper[1u2]; // line 1672
                    } else { // line 1673
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 1674
                            final_winner = upper[2u2]; // line 1675
                        } else { // line 1676
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 1677
                                final_winner = upper[0u2]; // line 1678
                            } else { // line 1679
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 1680
                                    final_winner = upper[2u2]; // line 1681
                                } else { // line 1682
                                    final_winner = 0u2; // line 1683
                                } // line 1684
                            } // line 1685
                        } // line 1686
                    } // line 1687
                } // line 1688
            } // line 1689
        } // line 1690
    } // line 1691
} // line 1692

/*   // line 1698
    0 = non assigned // line 1699
    1 = circle (player 1) // line 1700
    2 = cross (player 2) // line 1701
    Initial Condition:  // line 1702
    |   | O |   | // line 1703
    | O | X | X | // line 1704
    |   | O |   | // line 1705
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1706
*/  // line 1707

main (){ // line 1709
    u2 row_choice, column_choice; // line 1710
    upper[0u2] = 0u2; // line 1711
	upper[1u2] = 1u2; // line 1712
	upper[2u2] = 0u2; // line 1713
    middle[0u2] = 1u2; // line 1714
	middle[1u2] = 2u2; // line 1715
	middle[2u2] = 2u2; // line 1716
    lower[0u2] = 0u2; // line 1717
	lower[1u2] = 1u2; // line 1718
	lower[2u2] = 0u2; // line 1719

    final_winner = 0u2; // line 1721
    query sampleAction(2u2, row_choice, column_choice); // line 1722

} // line 1724

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1726
    bool another_turn; // line 1727
    u2 other_player; // line 1728
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 1729
    
    // sample a choice from the priori // line 1731
    query action_priori(current_player, row_choice, column_choice); // line 1732
    
    // is there a final_winner or is the grid filled? // line 1734
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 1735
    winning_condition(); // line 1736

    // if nobody has won and there is another turn to play... // line 1738
    if (final_winner == 0u2 && another_turn) {     // line 1739
        // passing the turn // line 1740
        if (current_player == 1u2) { // line 1741
            other_player = 2u2; // line 1742
        } else { // line 1743
            other_player = 1u2; // line 1744
        } // line 1745
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 1746

    } else {} // line 1748

    // observing according to the utility of the outcome // line 1750
    expected_utility(current_player); // line 1751

    // returning row_choice and column_choice - the choice of the player // line 1753
} // line 1754


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1757
    u2 sampled_row_choice, sampled_column_choice; // line 1758

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1760
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1761

    // observe that the choice is feasible, and update the grid // line 1763
    if (sampled_row_choice == 0u2) { // line 1764
        observe upper[sampled_column_choice] == 0u2; // line 1765
        upper[sampled_column_choice] = current_player; // line 1766
    } else { // line 1767
        if (sampled_row_choice == 1u2) { // line 1768
            observe middle[sampled_column_choice] == 0u2; // line 1769
            middle[sampled_column_choice] = current_player; // line 1770
        } else { // line 1771
            observe lower[sampled_column_choice] == 0u2; // line 1772
            lower[sampled_column_choice] = current_player; // line 1773
        } // line 1774
    } // line 1775
    row_choice = sampled_row_choice; // line 1776
    column_choice = sampled_column_choice; // line 1777
} // line 1778

expected_utility(u2 current_player) { // line 1780
    bool coin_flip; // line 1781
    u4 utility; // line 1782

    if (final_winner == current_player) { // line 1784
        utility = 10u4; // line 1785
    } else { // line 1786
        if (final_winner == 0u2) { // line 1787
        utility = 5u4; // line 1788
        } else { // line 1789
            utility = 1u4; // line 1790
        } // line 1791
    } // line 1792

    // outcome should range from 0 to 10 // line 1794
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 1795
    observe coin_flip; // line 1796
} // line 1797

winning_condition() { // line 1799
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 1800
        final_winner = upper[0u2]; // line 1801
    } else { // line 1802
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 1803
            final_winner = middle[0u2]; // line 1804
        } else { // line 1805
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 1806
                final_winner = lower[0u2]; // line 1807
            } else { // line 1808
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 1809
                    final_winner = upper[0u2]; // line 1810
                } else { // line 1811
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 1812
                        final_winner = upper[1u2]; // line 1813
                    } else { // line 1814
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 1815
                            final_winner = upper[2u2]; // line 1816
                        } else { // line 1817
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 1818
                                final_winner = upper[0u2]; // line 1819
                            } else { // line 1820
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 1821
                                    final_winner = upper[2u2]; // line 1822
                                } else { // line 1823
                                    final_winner = 0u2; // line 1824
                                } // line 1825
                            } // line 1826
                        } // line 1827
                    } // line 1828
                } // line 1829
            } // line 1830
        } // line 1831
    } // line 1832
} // line 1833

/*   // line 1839
    0 = non assigned // line 1840
    1 = circle (player 1) // line 1841
    2 = cross (player 2) // line 1842
    Initial Condition:  // line 1843
    |   | O |   | // line 1844
    | O | X | X | // line 1845
    |   | O |   | // line 1846
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1847
*/  // line 1848

main (){ // line 1850
    u2 row_choice, column_choice; // line 1851
    upper[0u2] = 0u2; // line 1852
	upper[1u2] = 1u2; // line 1853
	upper[2u2] = 0u2; // line 1854
    middle[0u2] = 1u2; // line 1855
	middle[1u2] = 2u2; // line 1856
	middle[2u2] = 2u2; // line 1857
    lower[0u2] = 0u2; // line 1858
	lower[1u2] = 1u2; // line 1859
	lower[2u2] = 0u2; // line 1860

    final_winner = 0u2; // line 1862
    query sampleAction(2u2, row_choice, column_choice); // line 1863

} // line 1865

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1867
    bool another_turn; // line 1868
    u2 other_player; // line 1869
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 1870
    
    // sample a choice from the priori // line 1872
    query action_priori(current_player, row_choice, column_choice); // line 1873
    
    // is there a final_winner or is the grid filled? // line 1875
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 1876
    winning_condition(); // line 1877

    // if nobody has won and there is another turn to play... // line 1879
    if (final_winner == 0u2 && another_turn) {     // line 1880
        // passing the turn // line 1881
        if (current_player == 1u2) { // line 1882
            other_player = 2u2; // line 1883
        } else { // line 1884
            other_player = 1u2; // line 1885
        } // line 1886
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 1887

    } else {} // line 1889

    // observing according to the utility of the outcome // line 1891
    expected_utility(current_player); // line 1892

    // returning row_choice and column_choice - the choice of the player // line 1894
} // line 1895


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 1898
    u2 sampled_row_choice, sampled_column_choice; // line 1899

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1901
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 1902

    // observe that the choice is feasible, and update the grid // line 1904
    if (sampled_row_choice == 0u2) { // line 1905
        observe upper[sampled_column_choice] == 0u2; // line 1906
        upper[sampled_column_choice] = current_player; // line 1907
    } else { // line 1908
        if (sampled_row_choice == 1u2) { // line 1909
            observe middle[sampled_column_choice] == 0u2; // line 1910
            middle[sampled_column_choice] = current_player; // line 1911
        } else { // line 1912
            observe lower[sampled_column_choice] == 0u2; // line 1913
            lower[sampled_column_choice] = current_player; // line 1914
        } // line 1915
    } // line 1916
    row_choice = sampled_row_choice; // line 1917
    column_choice = sampled_column_choice; // line 1918
} // line 1919

expected_utility(u2 current_player) { // line 1921
    bool coin_flip; // line 1922
    u4 utility; // line 1923

    if (final_winner == current_player) { // line 1925
        utility = 10u4; // line 1926
    } else { // line 1927
        if (final_winner == 0u2) { // line 1928
        utility = 5u4; // line 1929
        } else { // line 1930
            utility = 1u4; // line 1931
        } // line 1932
    } // line 1933

    // outcome should range from 0 to 10 // line 1935
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 1936
    observe coin_flip; // line 1937
} // line 1938

winning_condition() { // line 1940
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 1941
        final_winner = upper[0u2]; // line 1942
    } else { // line 1943
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 1944
            final_winner = middle[0u2]; // line 1945
        } else { // line 1946
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 1947
                final_winner = lower[0u2]; // line 1948
            } else { // line 1949
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 1950
                    final_winner = upper[0u2]; // line 1951
                } else { // line 1952
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 1953
                        final_winner = upper[1u2]; // line 1954
                    } else { // line 1955
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 1956
                            final_winner = upper[2u2]; // line 1957
                        } else { // line 1958
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 1959
                                final_winner = upper[0u2]; // line 1960
                            } else { // line 1961
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 1962
                                    final_winner = upper[2u2]; // line 1963
                                } else { // line 1964
                                    final_winner = 0u2; // line 1965
                                } // line 1966
                            } // line 1967
                        } // line 1968
                    } // line 1969
                } // line 1970
            } // line 1971
        } // line 1972
    } // line 1973
} // line 1974

/*   // line 1980
    0 = non assigned // line 1981
    1 = circle (player 1) // line 1982
    2 = cross (player 2) // line 1983
    Initial Condition:  // line 1984
    |   | O |   | // line 1985
    | O | X | X | // line 1986
    |   | O |   | // line 1987
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 1988
*/  // line 1989

main (){ // line 1991
    u2 row_choice, column_choice; // line 1992
    upper[0u2] = 0u2; // line 1993
	upper[1u2] = 1u2; // line 1994
	upper[2u2] = 0u2; // line 1995
    middle[0u2] = 1u2; // line 1996
	middle[1u2] = 2u2; // line 1997
	middle[2u2] = 2u2; // line 1998
    lower[0u2] = 0u2; // line 1999
	lower[1u2] = 1u2; // line 2000
	lower[2u2] = 0u2; // line 2001

    final_winner = 0u2; // line 2003
    query sampleAction(2u2, row_choice, column_choice); // line 2004

} // line 2006

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2008
    bool another_turn; // line 2009
    u2 other_player; // line 2010
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2011
    
    // sample a choice from the priori // line 2013
    query action_priori(current_player, row_choice, column_choice); // line 2014
    
    // is there a final_winner or is the grid filled? // line 2016
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 2017
    winning_condition(); // line 2018

    // if nobody has won and there is another turn to play... // line 2020
    if (final_winner == 0u2 && another_turn) {     // line 2021
        // passing the turn // line 2022
        if (current_player == 1u2) { // line 2023
            other_player = 2u2; // line 2024
        } else { // line 2025
            other_player = 1u2; // line 2026
        } // line 2027
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 2028

    } else {} // line 2030

    // observing according to the utility of the outcome // line 2032
    expected_utility(current_player); // line 2033

    // returning row_choice and column_choice - the choice of the player // line 2035
} // line 2036


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2039
    u2 sampled_row_choice, sampled_column_choice; // line 2040

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2042
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2043

    // observe that the choice is feasible, and update the grid // line 2045
    if (sampled_row_choice == 0u2) { // line 2046
        observe upper[sampled_column_choice] == 0u2; // line 2047
        upper[sampled_column_choice] = current_player; // line 2048
    } else { // line 2049
        if (sampled_row_choice == 1u2) { // line 2050
            observe middle[sampled_column_choice] == 0u2; // line 2051
            middle[sampled_column_choice] = current_player; // line 2052
        } else { // line 2053
            observe lower[sampled_column_choice] == 0u2; // line 2054
            lower[sampled_column_choice] = current_player; // line 2055
        } // line 2056
    } // line 2057
    row_choice = sampled_row_choice; // line 2058
    column_choice = sampled_column_choice; // line 2059
} // line 2060

expected_utility(u2 current_player) { // line 2062
    bool coin_flip; // line 2063
    u4 utility; // line 2064

    if (final_winner == current_player) { // line 2066
        utility = 10u4; // line 2067
    } else { // line 2068
        if (final_winner == 0u2) { // line 2069
        utility = 5u4; // line 2070
        } else { // line 2071
            utility = 1u4; // line 2072
        } // line 2073
    } // line 2074

    // outcome should range from 0 to 10 // line 2076
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 2077
    observe coin_flip; // line 2078
} // line 2079

winning_condition() { // line 2081
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 2082
        final_winner = upper[0u2]; // line 2083
    } else { // line 2084
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 2085
            final_winner = middle[0u2]; // line 2086
        } else { // line 2087
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 2088
                final_winner = lower[0u2]; // line 2089
            } else { // line 2090
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 2091
                    final_winner = upper[0u2]; // line 2092
                } else { // line 2093
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 2094
                        final_winner = upper[1u2]; // line 2095
                    } else { // line 2096
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 2097
                            final_winner = upper[2u2]; // line 2098
                        } else { // line 2099
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 2100
                                final_winner = upper[0u2]; // line 2101
                            } else { // line 2102
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 2103
                                    final_winner = upper[2u2]; // line 2104
                                } else { // line 2105
                                    final_winner = 0u2; // line 2106
                                } // line 2107
                            } // line 2108
                        } // line 2109
                    } // line 2110
                } // line 2111
            } // line 2112
        } // line 2113
    } // line 2114
} // line 2115

/*   // line 2121
    0 = non assigned // line 2122
    1 = circle (player 1) // line 2123
    2 = cross (player 2) // line 2124
    Initial Condition:  // line 2125
    |   | O |   | // line 2126
    | O | X | X | // line 2127
    |   | O |   | // line 2128
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 2129
*/  // line 2130

main (){ // line 2132
    u2 row_choice, column_choice; // line 2133
    upper[0u2] = 0u2; // line 2134
	upper[1u2] = 1u2; // line 2135
	upper[2u2] = 0u2; // line 2136
    middle[0u2] = 1u2; // line 2137
	middle[1u2] = 2u2; // line 2138
	middle[2u2] = 2u2; // line 2139
    lower[0u2] = 0u2; // line 2140
	lower[1u2] = 1u2; // line 2141
	lower[2u2] = 0u2; // line 2142

    final_winner = 0u2; // line 2144
    query sampleAction(2u2, row_choice, column_choice); // line 2145

} // line 2147

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2149
    bool another_turn; // line 2150
    u2 other_player; // line 2151
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2152
    
    // sample a choice from the priori // line 2154
    query action_priori(current_player, row_choice, column_choice); // line 2155
    
    // is there a final_winner or is the grid filled? // line 2157
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 2158
    winning_condition(); // line 2159

    // if nobody has won and there is another turn to play... // line 2161
    if (final_winner == 0u2 && another_turn) {     // line 2162
        // passing the turn // line 2163
        if (current_player == 1u2) { // line 2164
            other_player = 2u2; // line 2165
        } else { // line 2166
            other_player = 1u2; // line 2167
        } // line 2168
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 2169

    } else {} // line 2171

    // observing according to the utility of the outcome // line 2173
    expected_utility(current_player); // line 2174

    // returning row_choice and column_choice - the choice of the player // line 2176
} // line 2177


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2180
    u2 sampled_row_choice, sampled_column_choice; // line 2181

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2183
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2184

    // observe that the choice is feasible, and update the grid // line 2186
    if (sampled_row_choice == 0u2) { // line 2187
        observe upper[sampled_column_choice] == 0u2; // line 2188
        upper[sampled_column_choice] = current_player; // line 2189
    } else { // line 2190
        if (sampled_row_choice == 1u2) { // line 2191
            observe middle[sampled_column_choice] == 0u2; // line 2192
            middle[sampled_column_choice] = current_player; // line 2193
        } else { // line 2194
            observe lower[sampled_column_choice] == 0u2; // line 2195
            lower[sampled_column_choice] = current_player; // line 2196
        } // line 2197
    } // line 2198
    row_choice = sampled_row_choice; // line 2199
    column_choice = sampled_column_choice; // line 2200
} // line 2201

expected_utility(u2 current_player) { // line 2203
    bool coin_flip; // line 2204
    u4 utility; // line 2205

    if (final_winner == current_player) { // line 2207
        utility = 10u4; // line 2208
    } else { // line 2209
        if (final_winner == 0u2) { // line 2210
        utility = 5u4; // line 2211
        } else { // line 2212
            utility = 1u4; // line 2213
        } // line 2214
    } // line 2215

    // outcome should range from 0 to 10 // line 2217
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 2218
    observe coin_flip; // line 2219
} // line 2220

winning_condition() { // line 2222
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 2223
        final_winner = upper[0u2]; // line 2224
    } else { // line 2225
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 2226
            final_winner = middle[0u2]; // line 2227
        } else { // line 2228
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 2229
                final_winner = lower[0u2]; // line 2230
            } else { // line 2231
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 2232
                    final_winner = upper[0u2]; // line 2233
                } else { // line 2234
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 2235
                        final_winner = upper[1u2]; // line 2236
                    } else { // line 2237
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 2238
                            final_winner = upper[2u2]; // line 2239
                        } else { // line 2240
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 2241
                                final_winner = upper[0u2]; // line 2242
                            } else { // line 2243
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 2244
                                    final_winner = upper[2u2]; // line 2245
                                } else { // line 2246
                                    final_winner = 0u2; // line 2247
                                } // line 2248
                            } // line 2249
                        } // line 2250
                    } // line 2251
                } // line 2252
            } // line 2253
        } // line 2254
    } // line 2255
} // line 2256

/*   // line 2262
    0 = non assigned // line 2263
    1 = circle (player 1) // line 2264
    2 = cross (player 2) // line 2265
    Initial Condition:  // line 2266
    |   | O |   | // line 2267
    | O | X | X | // line 2268
    |   | O |   | // line 2269
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 2270
*/  // line 2271

main (){ // line 2273
    u2 row_choice, column_choice; // line 2274
    upper[0u2] = 0u2; // line 2275
	upper[1u2] = 1u2; // line 2276
	upper[2u2] = 0u2; // line 2277
    middle[0u2] = 1u2; // line 2278
	middle[1u2] = 2u2; // line 2279
	middle[2u2] = 2u2; // line 2280
    lower[0u2] = 0u2; // line 2281
	lower[1u2] = 1u2; // line 2282
	lower[2u2] = 0u2; // line 2283

    final_winner = 0u2; // line 2285
    query sampleAction(2u2, row_choice, column_choice); // line 2286

} // line 2288

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2290
    bool another_turn; // line 2291
    u2 other_player; // line 2292
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2293
    
    // sample a choice from the priori // line 2295
    query action_priori(current_player, row_choice, column_choice); // line 2296
    
    // is there a final_winner or is the grid filled? // line 2298
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 2299
    winning_condition(); // line 2300

    // if nobody has won and there is another turn to play... // line 2302
    if (final_winner == 0u2 && another_turn) {     // line 2303
        // passing the turn // line 2304
        if (current_player == 1u2) { // line 2305
            other_player = 2u2; // line 2306
        } else { // line 2307
            other_player = 1u2; // line 2308
        } // line 2309
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 2310

    } else {} // line 2312

    // observing according to the utility of the outcome // line 2314
    expected_utility(current_player); // line 2315

    // returning row_choice and column_choice - the choice of the player // line 2317
} // line 2318


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2321
    u2 sampled_row_choice, sampled_column_choice; // line 2322

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2324
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2325

    // observe that the choice is feasible, and update the grid // line 2327
    if (sampled_row_choice == 0u2) { // line 2328
        observe upper[sampled_column_choice] == 0u2; // line 2329
        upper[sampled_column_choice] = current_player; // line 2330
    } else { // line 2331
        if (sampled_row_choice == 1u2) { // line 2332
            observe middle[sampled_column_choice] == 0u2; // line 2333
            middle[sampled_column_choice] = current_player; // line 2334
        } else { // line 2335
            observe lower[sampled_column_choice] == 0u2; // line 2336
            lower[sampled_column_choice] = current_player; // line 2337
        } // line 2338
    } // line 2339
    row_choice = sampled_row_choice; // line 2340
    column_choice = sampled_column_choice; // line 2341
} // line 2342

expected_utility(u2 current_player) { // line 2344
    bool coin_flip; // line 2345
    u4 utility; // line 2346

    if (final_winner == current_player) { // line 2348
        utility = 10u4; // line 2349
    } else { // line 2350
        if (final_winner == 0u2) { // line 2351
        utility = 5u4; // line 2352
        } else { // line 2353
            utility = 1u4; // line 2354
        } // line 2355
    } // line 2356

    // outcome should range from 0 to 10 // line 2358
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 2359
    observe coin_flip; // line 2360
} // line 2361

winning_condition() { // line 2363
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 2364
        final_winner = upper[0u2]; // line 2365
    } else { // line 2366
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 2367
            final_winner = middle[0u2]; // line 2368
        } else { // line 2369
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 2370
                final_winner = lower[0u2]; // line 2371
            } else { // line 2372
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 2373
                    final_winner = upper[0u2]; // line 2374
                } else { // line 2375
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 2376
                        final_winner = upper[1u2]; // line 2377
                    } else { // line 2378
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 2379
                            final_winner = upper[2u2]; // line 2380
                        } else { // line 2381
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 2382
                                final_winner = upper[0u2]; // line 2383
                            } else { // line 2384
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 2385
                                    final_winner = upper[2u2]; // line 2386
                                } else { // line 2387
                                    final_winner = 0u2; // line 2388
                                } // line 2389
                            } // line 2390
                        } // line 2391
                    } // line 2392
                } // line 2393
            } // line 2394
        } // line 2395
    } // line 2396
} // line 2397

/*   // line 2403
    0 = non assigned // line 2404
    1 = circle (player 1) // line 2405
    2 = cross (player 2) // line 2406
    Initial Condition:  // line 2407
    |   | O |   | // line 2408
    | O | X | X | // line 2409
    |   | O |   | // line 2410
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 2411
*/  // line 2412

main (){ // line 2414
    u2 row_choice, column_choice; // line 2415
    upper[0u2] = 0u2; // line 2416
	upper[1u2] = 1u2; // line 2417
	upper[2u2] = 0u2; // line 2418
    middle[0u2] = 1u2; // line 2419
	middle[1u2] = 2u2; // line 2420
	middle[2u2] = 2u2; // line 2421
    lower[0u2] = 0u2; // line 2422
	lower[1u2] = 1u2; // line 2423
	lower[2u2] = 0u2; // line 2424

    final_winner = 0u2; // line 2426
    query sampleAction(2u2, row_choice, column_choice); // line 2427

} // line 2429

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2431
    bool another_turn; // line 2432
    u2 other_player; // line 2433
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2434
    
    // sample a choice from the priori // line 2436
    query action_priori(current_player, row_choice, column_choice); // line 2437
    
    // is there a final_winner or is the grid filled? // line 2439
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 2440
    winning_condition(); // line 2441

    // if nobody has won and there is another turn to play... // line 2443
    if (final_winner == 0u2 && another_turn) {     // line 2444
        // passing the turn // line 2445
        if (current_player == 1u2) { // line 2446
            other_player = 2u2; // line 2447
        } else { // line 2448
            other_player = 1u2; // line 2449
        } // line 2450
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 2451

    } else {} // line 2453

    // observing according to the utility of the outcome // line 2455
    expected_utility(current_player); // line 2456

    // returning row_choice and column_choice - the choice of the player // line 2458
} // line 2459


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2462
    u2 sampled_row_choice, sampled_column_choice; // line 2463

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2465
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2466

    // observe that the choice is feasible, and update the grid // line 2468
    if (sampled_row_choice == 0u2) { // line 2469
        observe upper[sampled_column_choice] == 0u2; // line 2470
        upper[sampled_column_choice] = current_player; // line 2471
    } else { // line 2472
        if (sampled_row_choice == 1u2) { // line 2473
            observe middle[sampled_column_choice] == 0u2; // line 2474
            middle[sampled_column_choice] = current_player; // line 2475
        } else { // line 2476
            observe lower[sampled_column_choice] == 0u2; // line 2477
            lower[sampled_column_choice] = current_player; // line 2478
        } // line 2479
    } // line 2480
    row_choice = sampled_row_choice; // line 2481
    column_choice = sampled_column_choice; // line 2482
} // line 2483

expected_utility(u2 current_player) { // line 2485
    bool coin_flip; // line 2486
    u4 utility; // line 2487

    if (final_winner == current_player) { // line 2489
        utility = 10u4; // line 2490
    } else { // line 2491
        if (final_winner == 0u2) { // line 2492
        utility = 5u4; // line 2493
        } else { // line 2494
            utility = 1u4; // line 2495
        } // line 2496
    } // line 2497

    // outcome should range from 0 to 10 // line 2499
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 2500
    observe coin_flip; // line 2501
} // line 2502

winning_condition() { // line 2504
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 2505
        final_winner = upper[0u2]; // line 2506
    } else { // line 2507
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 2508
            final_winner = middle[0u2]; // line 2509
        } else { // line 2510
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 2511
                final_winner = lower[0u2]; // line 2512
            } else { // line 2513
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 2514
                    final_winner = upper[0u2]; // line 2515
                } else { // line 2516
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 2517
                        final_winner = upper[1u2]; // line 2518
                    } else { // line 2519
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 2520
                            final_winner = upper[2u2]; // line 2521
                        } else { // line 2522
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 2523
                                final_winner = upper[0u2]; // line 2524
                            } else { // line 2525
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 2526
                                    final_winner = upper[2u2]; // line 2527
                                } else { // line 2528
                                    final_winner = 0u2; // line 2529
                                } // line 2530
                            } // line 2531
                        } // line 2532
                    } // line 2533
                } // line 2534
            } // line 2535
        } // line 2536
    } // line 2537
} // line 2538

/*   // line 2544
    0 = non assigned // line 2545
    1 = circle (player 1) // line 2546
    2 = cross (player 2) // line 2547
    Initial Condition:  // line 2548
    |   | O |   | // line 2549
    | O | X | X | // line 2550
    |   | O |   | // line 2551
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 2552
*/  // line 2553

main (){ // line 2555
    u2 row_choice, column_choice; // line 2556
    upper[0u2] = 0u2; // line 2557
	upper[1u2] = 1u2; // line 2558
	upper[2u2] = 0u2; // line 2559
    middle[0u2] = 1u2; // line 2560
	middle[1u2] = 2u2; // line 2561
	middle[2u2] = 2u2; // line 2562
    lower[0u2] = 0u2; // line 2563
	lower[1u2] = 1u2; // line 2564
	lower[2u2] = 0u2; // line 2565

    final_winner = 0u2; // line 2567
    query sampleAction(2u2, row_choice, column_choice); // line 2568

} // line 2570

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2572
    bool another_turn; // line 2573
    u2 other_player; // line 2574
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2575
    
    // sample a choice from the priori // line 2577
    query action_priori(current_player, row_choice, column_choice); // line 2578
    
    // is there a final_winner or is the grid filled? // line 2580
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 2581
    winning_condition(); // line 2582

    // if nobody has won and there is another turn to play... // line 2584
    if (final_winner == 0u2 && another_turn) {     // line 2585
        // passing the turn // line 2586
        if (current_player == 1u2) { // line 2587
            other_player = 2u2; // line 2588
        } else { // line 2589
            other_player = 1u2; // line 2590
        } // line 2591
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 2592

    } else {} // line 2594

    // observing according to the utility of the outcome // line 2596
    expected_utility(current_player); // line 2597

    // returning row_choice and column_choice - the choice of the player // line 2599
} // line 2600


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2603
    u2 sampled_row_choice, sampled_column_choice; // line 2604

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2606
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2607

    // observe that the choice is feasible, and update the grid // line 2609
    if (sampled_row_choice == 0u2) { // line 2610
        observe upper[sampled_column_choice] == 0u2; // line 2611
        upper[sampled_column_choice] = current_player; // line 2612
    } else { // line 2613
        if (sampled_row_choice == 1u2) { // line 2614
            observe middle[sampled_column_choice] == 0u2; // line 2615
            middle[sampled_column_choice] = current_player; // line 2616
        } else { // line 2617
            observe lower[sampled_column_choice] == 0u2; // line 2618
            lower[sampled_column_choice] = current_player; // line 2619
        } // line 2620
    } // line 2621
    row_choice = sampled_row_choice; // line 2622
    column_choice = sampled_column_choice; // line 2623
} // line 2624

expected_utility(u2 current_player) { // line 2626
    bool coin_flip; // line 2627
    u4 utility; // line 2628

    if (final_winner == current_player) { // line 2630
        utility = 10u4; // line 2631
    } else { // line 2632
        if (final_winner == 0u2) { // line 2633
        utility = 5u4; // line 2634
        } else { // line 2635
            utility = 1u4; // line 2636
        } // line 2637
    } // line 2638

    // outcome should range from 0 to 10 // line 2640
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 2641
    observe coin_flip; // line 2642
} // line 2643

winning_condition() { // line 2645
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 2646
        final_winner = upper[0u2]; // line 2647
    } else { // line 2648
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 2649
            final_winner = middle[0u2]; // line 2650
        } else { // line 2651
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 2652
                final_winner = lower[0u2]; // line 2653
            } else { // line 2654
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 2655
                    final_winner = upper[0u2]; // line 2656
                } else { // line 2657
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 2658
                        final_winner = upper[1u2]; // line 2659
                    } else { // line 2660
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 2661
                            final_winner = upper[2u2]; // line 2662
                        } else { // line 2663
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 2664
                                final_winner = upper[0u2]; // line 2665
                            } else { // line 2666
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 2667
                                    final_winner = upper[2u2]; // line 2668
                                } else { // line 2669
                                    final_winner = 0u2; // line 2670
                                } // line 2671
                            } // line 2672
                        } // line 2673
                    } // line 2674
                } // line 2675
            } // line 2676
        } // line 2677
    } // line 2678
} // line 2679

/*   // line 2685
    0 = non assigned // line 2686
    1 = circle (player 1) // line 2687
    2 = cross (player 2) // line 2688
    Initial Condition:  // line 2689
    |   | O |   | // line 2690
    | O | X | X | // line 2691
    |   | O |   | // line 2692
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 2693
*/  // line 2694

main (){ // line 2696
    u2 row_choice, column_choice; // line 2697
    upper[0u2] = 0u2; // line 2698
	upper[1u2] = 1u2; // line 2699
	upper[2u2] = 0u2; // line 2700
    middle[0u2] = 1u2; // line 2701
	middle[1u2] = 2u2; // line 2702
	middle[2u2] = 2u2; // line 2703
    lower[0u2] = 0u2; // line 2704
	lower[1u2] = 1u2; // line 2705
	lower[2u2] = 0u2; // line 2706

    final_winner = 0u2; // line 2708
    query sampleAction(2u2, row_choice, column_choice); // line 2709

} // line 2711

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2713
    bool another_turn; // line 2714
    u2 other_player; // line 2715
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2716
    
    // sample a choice from the priori // line 2718
    query action_priori(current_player, row_choice, column_choice); // line 2719
    
    // is there a final_winner or is the grid filled? // line 2721
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 2722
    winning_condition(); // line 2723

    // if nobody has won and there is another turn to play... // line 2725
    if (final_winner == 0u2 && another_turn) {     // line 2726
        // passing the turn // line 2727
        if (current_player == 1u2) { // line 2728
            other_player = 2u2; // line 2729
        } else { // line 2730
            other_player = 1u2; // line 2731
        } // line 2732
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 2733

    } else {} // line 2735

    // observing according to the utility of the outcome // line 2737
    expected_utility(current_player); // line 2738

    // returning row_choice and column_choice - the choice of the player // line 2740
} // line 2741


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2744
    u2 sampled_row_choice, sampled_column_choice; // line 2745

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2747
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2748

    // observe that the choice is feasible, and update the grid // line 2750
    if (sampled_row_choice == 0u2) { // line 2751
        observe upper[sampled_column_choice] == 0u2; // line 2752
        upper[sampled_column_choice] = current_player; // line 2753
    } else { // line 2754
        if (sampled_row_choice == 1u2) { // line 2755
            observe middle[sampled_column_choice] == 0u2; // line 2756
            middle[sampled_column_choice] = current_player; // line 2757
        } else { // line 2758
            observe lower[sampled_column_choice] == 0u2; // line 2759
            lower[sampled_column_choice] = current_player; // line 2760
        } // line 2761
    } // line 2762
    row_choice = sampled_row_choice; // line 2763
    column_choice = sampled_column_choice; // line 2764
} // line 2765

expected_utility(u2 current_player) { // line 2767
    bool coin_flip; // line 2768
    u4 utility; // line 2769

    if (final_winner == current_player) { // line 2771
        utility = 10u4; // line 2772
    } else { // line 2773
        if (final_winner == 0u2) { // line 2774
        utility = 5u4; // line 2775
        } else { // line 2776
            utility = 1u4; // line 2777
        } // line 2778
    } // line 2779

    // outcome should range from 0 to 10 // line 2781
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 2782
    observe coin_flip; // line 2783
} // line 2784

winning_condition() { // line 2786
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 2787
        final_winner = upper[0u2]; // line 2788
    } else { // line 2789
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 2790
            final_winner = middle[0u2]; // line 2791
        } else { // line 2792
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 2793
                final_winner = lower[0u2]; // line 2794
            } else { // line 2795
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 2796
                    final_winner = upper[0u2]; // line 2797
                } else { // line 2798
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 2799
                        final_winner = upper[1u2]; // line 2800
                    } else { // line 2801
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 2802
                            final_winner = upper[2u2]; // line 2803
                        } else { // line 2804
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 2805
                                final_winner = upper[0u2]; // line 2806
                            } else { // line 2807
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 2808
                                    final_winner = upper[2u2]; // line 2809
                                } else { // line 2810
                                    final_winner = 0u2; // line 2811
                                } // line 2812
                            } // line 2813
                        } // line 2814
                    } // line 2815
                } // line 2816
            } // line 2817
        } // line 2818
    } // line 2819
} // line 2820

/*   // line 2826
    0 = non assigned // line 2827
    1 = circle (player 1) // line 2828
    2 = cross (player 2) // line 2829
    Initial Condition:  // line 2830
    |   | O |   | // line 2831
    | O | X | X | // line 2832
    |   | O |   | // line 2833
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 2834
*/  // line 2835

main (){ // line 2837
    u2 row_choice, column_choice; // line 2838
    upper[0u2] = 0u2; // line 2839
	upper[1u2] = 1u2; // line 2840
	upper[2u2] = 0u2; // line 2841
    middle[0u2] = 1u2; // line 2842
	middle[1u2] = 2u2; // line 2843
	middle[2u2] = 2u2; // line 2844
    lower[0u2] = 0u2; // line 2845
	lower[1u2] = 1u2; // line 2846
	lower[2u2] = 0u2; // line 2847

    final_winner = 0u2; // line 2849
    query sampleAction(2u2, row_choice, column_choice); // line 2850

} // line 2852

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2854
    bool another_turn; // line 2855
    u2 other_player; // line 2856
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2857
    
    // sample a choice from the priori // line 2859
    query action_priori(current_player, row_choice, column_choice); // line 2860
    
    // is there a final_winner or is the grid filled? // line 2862
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 2863
    winning_condition(); // line 2864

    // if nobody has won and there is another turn to play... // line 2866
    if (final_winner == 0u2 && another_turn) {     // line 2867
        // passing the turn // line 2868
        if (current_player == 1u2) { // line 2869
            other_player = 2u2; // line 2870
        } else { // line 2871
            other_player = 1u2; // line 2872
        } // line 2873
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 2874

    } else {} // line 2876

    // observing according to the utility of the outcome // line 2878
    expected_utility(current_player); // line 2879

    // returning row_choice and column_choice - the choice of the player // line 2881
} // line 2882


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2885
    u2 sampled_row_choice, sampled_column_choice; // line 2886

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2888
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 2889

    // observe that the choice is feasible, and update the grid // line 2891
    if (sampled_row_choice == 0u2) { // line 2892
        observe upper[sampled_column_choice] == 0u2; // line 2893
        upper[sampled_column_choice] = current_player; // line 2894
    } else { // line 2895
        if (sampled_row_choice == 1u2) { // line 2896
            observe middle[sampled_column_choice] == 0u2; // line 2897
            middle[sampled_column_choice] = current_player; // line 2898
        } else { // line 2899
            observe lower[sampled_column_choice] == 0u2; // line 2900
            lower[sampled_column_choice] = current_player; // line 2901
        } // line 2902
    } // line 2903
    row_choice = sampled_row_choice; // line 2904
    column_choice = sampled_column_choice; // line 2905
} // line 2906

expected_utility(u2 current_player) { // line 2908
    bool coin_flip; // line 2909
    u4 utility; // line 2910

    if (final_winner == current_player) { // line 2912
        utility = 10u4; // line 2913
    } else { // line 2914
        if (final_winner == 0u2) { // line 2915
        utility = 5u4; // line 2916
        } else { // line 2917
            utility = 1u4; // line 2918
        } // line 2919
    } // line 2920

    // outcome should range from 0 to 10 // line 2922
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 2923
    observe coin_flip; // line 2924
} // line 2925

winning_condition() { // line 2927
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 2928
        final_winner = upper[0u2]; // line 2929
    } else { // line 2930
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 2931
            final_winner = middle[0u2]; // line 2932
        } else { // line 2933
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 2934
                final_winner = lower[0u2]; // line 2935
            } else { // line 2936
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 2937
                    final_winner = upper[0u2]; // line 2938
                } else { // line 2939
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 2940
                        final_winner = upper[1u2]; // line 2941
                    } else { // line 2942
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 2943
                            final_winner = upper[2u2]; // line 2944
                        } else { // line 2945
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 2946
                                final_winner = upper[0u2]; // line 2947
                            } else { // line 2948
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 2949
                                    final_winner = upper[2u2]; // line 2950
                                } else { // line 2951
                                    final_winner = 0u2; // line 2952
                                } // line 2953
                            } // line 2954
                        } // line 2955
                    } // line 2956
                } // line 2957
            } // line 2958
        } // line 2959
    } // line 2960
} // line 2961

/*   // line 2967
    0 = non assigned // line 2968
    1 = circle (player 1) // line 2969
    2 = cross (player 2) // line 2970
    Initial Condition:  // line 2971
    |   | O |   | // line 2972
    | O | X | X | // line 2973
    |   | O |   | // line 2974
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 2975
*/  // line 2976

main (){ // line 2978
    u2 row_choice, column_choice; // line 2979
    upper[0u2] = 0u2; // line 2980
	upper[1u2] = 1u2; // line 2981
	upper[2u2] = 0u2; // line 2982
    middle[0u2] = 1u2; // line 2983
	middle[1u2] = 2u2; // line 2984
	middle[2u2] = 2u2; // line 2985
    lower[0u2] = 0u2; // line 2986
	lower[1u2] = 1u2; // line 2987
	lower[2u2] = 0u2; // line 2988

    final_winner = 0u2; // line 2990
    query sampleAction(2u2, row_choice, column_choice); // line 2991

} // line 2993

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 2995
    bool another_turn; // line 2996
    u2 other_player; // line 2997
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 2998
    
    // sample a choice from the priori // line 3000
    query action_priori(current_player, row_choice, column_choice); // line 3001
    
    // is there a final_winner or is the grid filled? // line 3003
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3004
    winning_condition(); // line 3005

    // if nobody has won and there is another turn to play... // line 3007
    if (final_winner == 0u2 && another_turn) {     // line 3008
        // passing the turn // line 3009
        if (current_player == 1u2) { // line 3010
            other_player = 2u2; // line 3011
        } else { // line 3012
            other_player = 1u2; // line 3013
        } // line 3014
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 3015

    } else {} // line 3017

    // observing according to the utility of the outcome // line 3019
    expected_utility(current_player); // line 3020

    // returning row_choice and column_choice - the choice of the player // line 3022
} // line 3023


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3026
    u2 sampled_row_choice, sampled_column_choice; // line 3027

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3029
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3030

    // observe that the choice is feasible, and update the grid // line 3032
    if (sampled_row_choice == 0u2) { // line 3033
        observe upper[sampled_column_choice] == 0u2; // line 3034
        upper[sampled_column_choice] = current_player; // line 3035
    } else { // line 3036
        if (sampled_row_choice == 1u2) { // line 3037
            observe middle[sampled_column_choice] == 0u2; // line 3038
            middle[sampled_column_choice] = current_player; // line 3039
        } else { // line 3040
            observe lower[sampled_column_choice] == 0u2; // line 3041
            lower[sampled_column_choice] = current_player; // line 3042
        } // line 3043
    } // line 3044
    row_choice = sampled_row_choice; // line 3045
    column_choice = sampled_column_choice; // line 3046
} // line 3047

expected_utility(u2 current_player) { // line 3049
    bool coin_flip; // line 3050
    u4 utility; // line 3051

    if (final_winner == current_player) { // line 3053
        utility = 10u4; // line 3054
    } else { // line 3055
        if (final_winner == 0u2) { // line 3056
        utility = 5u4; // line 3057
        } else { // line 3058
            utility = 1u4; // line 3059
        } // line 3060
    } // line 3061

    // outcome should range from 0 to 10 // line 3063
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 3064
    observe coin_flip; // line 3065
} // line 3066

winning_condition() { // line 3068
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 3069
        final_winner = upper[0u2]; // line 3070
    } else { // line 3071
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 3072
            final_winner = middle[0u2]; // line 3073
        } else { // line 3074
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 3075
                final_winner = lower[0u2]; // line 3076
            } else { // line 3077
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 3078
                    final_winner = upper[0u2]; // line 3079
                } else { // line 3080
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 3081
                        final_winner = upper[1u2]; // line 3082
                    } else { // line 3083
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 3084
                            final_winner = upper[2u2]; // line 3085
                        } else { // line 3086
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 3087
                                final_winner = upper[0u2]; // line 3088
                            } else { // line 3089
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 3090
                                    final_winner = upper[2u2]; // line 3091
                                } else { // line 3092
                                    final_winner = 0u2; // line 3093
                                } // line 3094
                            } // line 3095
                        } // line 3096
                    } // line 3097
                } // line 3098
            } // line 3099
        } // line 3100
    } // line 3101
} // line 3102

/*   // line 3108
    0 = non assigned // line 3109
    1 = circle (player 1) // line 3110
    2 = cross (player 2) // line 3111
    Initial Condition:  // line 3112
    |   | O |   | // line 3113
    | O | X | X | // line 3114
    |   | O |   | // line 3115
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 3116
*/  // line 3117

main (){ // line 3119
    u2 row_choice, column_choice; // line 3120
    upper[0u2] = 0u2; // line 3121
	upper[1u2] = 1u2; // line 3122
	upper[2u2] = 0u2; // line 3123
    middle[0u2] = 1u2; // line 3124
	middle[1u2] = 2u2; // line 3125
	middle[2u2] = 2u2; // line 3126
    lower[0u2] = 0u2; // line 3127
	lower[1u2] = 1u2; // line 3128
	lower[2u2] = 0u2; // line 3129

    final_winner = 0u2; // line 3131
    query sampleAction(2u2, row_choice, column_choice); // line 3132

} // line 3134

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3136
    bool another_turn; // line 3137
    u2 other_player; // line 3138
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 3139
    
    // sample a choice from the priori // line 3141
    query action_priori(current_player, row_choice, column_choice); // line 3142
    
    // is there a final_winner or is the grid filled? // line 3144
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3145
    winning_condition(); // line 3146

    // if nobody has won and there is another turn to play... // line 3148
    if (final_winner == 0u2 && another_turn) {     // line 3149
        // passing the turn // line 3150
        if (current_player == 1u2) { // line 3151
            other_player = 2u2; // line 3152
        } else { // line 3153
            other_player = 1u2; // line 3154
        } // line 3155
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 3156

    } else {} // line 3158

    // observing according to the utility of the outcome // line 3160
    expected_utility(current_player); // line 3161

    // returning row_choice and column_choice - the choice of the player // line 3163
} // line 3164


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3167
    u2 sampled_row_choice, sampled_column_choice; // line 3168

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3170
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3171

    // observe that the choice is feasible, and update the grid // line 3173
    if (sampled_row_choice == 0u2) { // line 3174
        observe upper[sampled_column_choice] == 0u2; // line 3175
        upper[sampled_column_choice] = current_player; // line 3176
    } else { // line 3177
        if (sampled_row_choice == 1u2) { // line 3178
            observe middle[sampled_column_choice] == 0u2; // line 3179
            middle[sampled_column_choice] = current_player; // line 3180
        } else { // line 3181
            observe lower[sampled_column_choice] == 0u2; // line 3182
            lower[sampled_column_choice] = current_player; // line 3183
        } // line 3184
    } // line 3185
    row_choice = sampled_row_choice; // line 3186
    column_choice = sampled_column_choice; // line 3187
} // line 3188

expected_utility(u2 current_player) { // line 3190
    bool coin_flip; // line 3191
    u4 utility; // line 3192

    if (final_winner == current_player) { // line 3194
        utility = 10u4; // line 3195
    } else { // line 3196
        if (final_winner == 0u2) { // line 3197
        utility = 5u4; // line 3198
        } else { // line 3199
            utility = 1u4; // line 3200
        } // line 3201
    } // line 3202

    // outcome should range from 0 to 10 // line 3204
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 3205
    observe coin_flip; // line 3206
} // line 3207

winning_condition() { // line 3209
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 3210
        final_winner = upper[0u2]; // line 3211
    } else { // line 3212
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 3213
            final_winner = middle[0u2]; // line 3214
        } else { // line 3215
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 3216
                final_winner = lower[0u2]; // line 3217
            } else { // line 3218
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 3219
                    final_winner = upper[0u2]; // line 3220
                } else { // line 3221
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 3222
                        final_winner = upper[1u2]; // line 3223
                    } else { // line 3224
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 3225
                            final_winner = upper[2u2]; // line 3226
                        } else { // line 3227
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 3228
                                final_winner = upper[0u2]; // line 3229
                            } else { // line 3230
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 3231
                                    final_winner = upper[2u2]; // line 3232
                                } else { // line 3233
                                    final_winner = 0u2; // line 3234
                                } // line 3235
                            } // line 3236
                        } // line 3237
                    } // line 3238
                } // line 3239
            } // line 3240
        } // line 3241
    } // line 3242
} // line 3243
u2[3] upper; // line 3244
u2[3] middle; // line 3245
u2[3] lower; // line 3246
u2 final_winner; // line 3247

/*   // line 3249
    0 = non assigned // line 3250
    1 = circle (player 1) // line 3251
    2 = cross (player 2) // line 3252
    Initial Condition:  // line 3253
    |   | O |   | // line 3254
    | O | X | X | // line 3255
    |   | O |   | // line 3256
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 3257
*/  // line 3258

main (){ // line 3260
    u2 row_choice, column_choice; // line 3261
    upper[0u2] = 0u2; // line 3262
	upper[1u2] = 1u2; // line 3263
	upper[2u2] = 0u2; // line 3264
    middle[0u2] = 1u2; // line 3265
	middle[1u2] = 2u2; // line 3266
	middle[2u2] = 2u2; // line 3267
    lower[0u2] = 0u2; // line 3268
	lower[1u2] = 1u2; // line 3269
	lower[2u2] = 0u2; // line 3270

    final_winner = 0u2; // line 3272
    query sampleAction(2u2, row_choice, column_choice); // line 3273

} // line 3275

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3277
    bool another_turn; // line 3278
    u2 other_player; // line 3279
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 3280
    
    // sample a choice from the priori // line 3282
    query action_priori(current_player, row_choice, column_choice); // line 3283
    
    // is there a final_winner or is the grid filled? // line 3285
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3286
    winning_condition(); // line 3287

    // if nobody has won and there is another turn to play... // line 3289
    if (final_winner == 0u2 && another_turn) {     // line 3290
        // passing the turn // line 3291
        if (current_player == 1u2) { // line 3292
            other_player = 2u2; // line 3293
        } else { // line 3294
            other_player = 1u2; // line 3295
        } // line 3296
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 3297

    } else {} // line 3299

    // observing according to the utility of the outcome // line 3301
    expected_utility(current_player); // line 3302

    // returning row_choice and column_choice - the choice of the player // line 3304
} // line 3305


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3308
    u2 sampled_row_choice, sampled_column_choice; // line 3309

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3311
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3312

    // observe that the choice is feasible, and update the grid // line 3314
    if (sampled_row_choice == 0u2) { // line 3315
        observe upper[sampled_column_choice] == 0u2; // line 3316
        upper[sampled_column_choice] = current_player; // line 3317
    } else { // line 3318
        if (sampled_row_choice == 1u2) { // line 3319
            observe middle[sampled_column_choice] == 0u2; // line 3320
            middle[sampled_column_choice] = current_player; // line 3321
        } else { // line 3322
            observe lower[sampled_column_choice] == 0u2; // line 3323
            lower[sampled_column_choice] = current_player; // line 3324
        } // line 3325
    } // line 3326
    row_choice = sampled_row_choice; // line 3327
    column_choice = sampled_column_choice; // line 3328
} // line 3329

expected_utility(u2 current_player) { // line 3331
    bool coin_flip; // line 3332
    u4 utility; // line 3333

    if (final_winner == current_player) { // line 3335
        utility = 10u4; // line 3336
    } else { // line 3337
        if (final_winner == 0u2) { // line 3338
        utility = 5u4; // line 3339
        } else { // line 3340
            utility = 1u4; // line 3341
        } // line 3342
    } // line 3343

    // outcome should range from 0 to 10 // line 3345
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 3346
    observe coin_flip; // line 3347
} // line 3348

winning_condition() { // line 3350
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 3351
        final_winner = upper[0u2]; // line 3352
    } else { // line 3353
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 3354
            final_winner = middle[0u2]; // line 3355
        } else { // line 3356
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 3357
                final_winner = lower[0u2]; // line 3358
            } else { // line 3359
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 3360
                    final_winner = upper[0u2]; // line 3361
                } else { // line 3362
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 3363
                        final_winner = upper[1u2]; // line 3364
                    } else { // line 3365
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 3366
                            final_winner = upper[2u2]; // line 3367
                        } else { // line 3368
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 3369
                                final_winner = upper[0u2]; // line 3370
                            } else { // line 3371
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 3372
                                    final_winner = upper[2u2]; // line 3373
                                } else { // line 3374
                                    final_winner = 0u2; // line 3375
                                } // line 3376
                            } // line 3377
                        } // line 3378
                    } // line 3379
                } // line 3380
            } // line 3381
        } // line 3382
    } // line 3383
} // line 3384
u2[3] upper; // line 3385
u2[3] middle; // line 3386
u2[3] lower; // line 3387
u2 final_winner; // line 3388

/*   // line 3390
    0 = non assigned // line 3391
    1 = circle (player 1) // line 3392
    2 = cross (player 2) // line 3393
    Initial Condition:  // line 3394
    |   | O |   | // line 3395
    | O | X | X | // line 3396
    |   | O |   | // line 3397
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 3398
*/  // line 3399

main (){ // line 3401
    u2 row_choice, column_choice; // line 3402
    upper[0u2] = 0u2; // line 3403
	upper[1u2] = 1u2; // line 3404
	upper[2u2] = 0u2; // line 3405
    middle[0u2] = 1u2; // line 3406
	middle[1u2] = 2u2; // line 3407
	middle[2u2] = 2u2; // line 3408
    lower[0u2] = 0u2; // line 3409
	lower[1u2] = 1u2; // line 3410
	lower[2u2] = 0u2; // line 3411

    final_winner = 0u2; // line 3413
    query sampleAction(2u2, row_choice, column_choice); // line 3414

} // line 3416

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3418
    bool another_turn; // line 3419
    u2 other_player; // line 3420
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 3421
    
    // sample a choice from the priori // line 3423
    query action_priori(current_player, row_choice, column_choice); // line 3424
    
    // is there a final_winner or is the grid filled? // line 3426
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3427
    winning_condition(); // line 3428

    // if nobody has won and there is another turn to play... // line 3430
    if (final_winner == 0u2 && another_turn) {     // line 3431
        // passing the turn // line 3432
        if (current_player == 1u2) { // line 3433
            other_player = 2u2; // line 3434
        } else { // line 3435
            other_player = 1u2; // line 3436
        } // line 3437
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 3438

    } else {} // line 3440

    // observing according to the utility of the outcome // line 3442
    expected_utility(current_player); // line 3443

    // returning row_choice and column_choice - the choice of the player // line 3445
} // line 3446


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3449
    u2 sampled_row_choice, sampled_column_choice; // line 3450

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3452
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3453

    // observe that the choice is feasible, and update the grid // line 3455
    if (sampled_row_choice == 0u2) { // line 3456
        observe upper[sampled_column_choice] == 0u2; // line 3457
        upper[sampled_column_choice] = current_player; // line 3458
    } else { // line 3459
        if (sampled_row_choice == 1u2) { // line 3460
            observe middle[sampled_column_choice] == 0u2; // line 3461
            middle[sampled_column_choice] = current_player; // line 3462
        } else { // line 3463
            observe lower[sampled_column_choice] == 0u2; // line 3464
            lower[sampled_column_choice] = current_player; // line 3465
        } // line 3466
    } // line 3467
    row_choice = sampled_row_choice; // line 3468
    column_choice = sampled_column_choice; // line 3469
} // line 3470

expected_utility(u2 current_player) { // line 3472
    bool coin_flip; // line 3473
    u4 utility; // line 3474

    if (final_winner == current_player) { // line 3476
        utility = 10u4; // line 3477
    } else { // line 3478
        if (final_winner == 0u2) { // line 3479
        utility = 5u4; // line 3480
        } else { // line 3481
            utility = 1u4; // line 3482
        } // line 3483
    } // line 3484

    // outcome should range from 0 to 10 // line 3486
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 3487
    observe coin_flip; // line 3488
} // line 3489

winning_condition() { // line 3491
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 3492
        final_winner = upper[0u2]; // line 3493
    } else { // line 3494
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 3495
            final_winner = middle[0u2]; // line 3496
        } else { // line 3497
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 3498
                final_winner = lower[0u2]; // line 3499
            } else { // line 3500
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 3501
                    final_winner = upper[0u2]; // line 3502
                } else { // line 3503
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 3504
                        final_winner = upper[1u2]; // line 3505
                    } else { // line 3506
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 3507
                            final_winner = upper[2u2]; // line 3508
                        } else { // line 3509
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 3510
                                final_winner = upper[0u2]; // line 3511
                            } else { // line 3512
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 3513
                                    final_winner = upper[2u2]; // line 3514
                                } else { // line 3515
                                    final_winner = 0u2; // line 3516
                                } // line 3517
                            } // line 3518
                        } // line 3519
                    } // line 3520
                } // line 3521
            } // line 3522
        } // line 3523
    } // line 3524
} // line 3525
u2[3] upper; // line 3526
u2[3] middle; // line 3527
u2[3] lower; // line 3528
u2 final_winner; // line 3529

/*   // line 3531
    0 = non assigned // line 3532
    1 = circle (player 1) // line 3533
    2 = cross (player 2) // line 3534
    Initial Condition:  // line 3535
    |   | O |   | // line 3536
    | O | X | X | // line 3537
    |   | O |   | // line 3538
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 3539
*/  // line 3540

main (){ // line 3542
    u2 row_choice, column_choice; // line 3543
    upper[0u2] = 0u2; // line 3544
	upper[1u2] = 1u2; // line 3545
	upper[2u2] = 0u2; // line 3546
    middle[0u2] = 1u2; // line 3547
	middle[1u2] = 2u2; // line 3548
	middle[2u2] = 2u2; // line 3549
    lower[0u2] = 0u2; // line 3550
	lower[1u2] = 1u2; // line 3551
	lower[2u2] = 0u2; // line 3552

    final_winner = 0u2; // line 3554
    query sampleAction(2u2, row_choice, column_choice); // line 3555

} // line 3557

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3559
    bool another_turn; // line 3560
    u2 other_player; // line 3561
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 3562
    
    // sample a choice from the priori // line 3564
    query action_priori(current_player, row_choice, column_choice); // line 3565
    
    // is there a final_winner or is the grid filled? // line 3567
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3568
    winning_condition(); // line 3569

    // if nobody has won and there is another turn to play... // line 3571
    if (final_winner == 0u2 && another_turn) {     // line 3572
        // passing the turn // line 3573
        if (current_player == 1u2) { // line 3574
            other_player = 2u2; // line 3575
        } else { // line 3576
            other_player = 1u2; // line 3577
        } // line 3578
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 3579

    } else {} // line 3581

    // observing according to the utility of the outcome // line 3583
    expected_utility(current_player); // line 3584

    // returning row_choice and column_choice - the choice of the player // line 3586
} // line 3587


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3590
    u2 sampled_row_choice, sampled_column_choice; // line 3591

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3593
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3594

    // observe that the choice is feasible, and update the grid // line 3596
    if (sampled_row_choice == 0u2) { // line 3597
        observe upper[sampled_column_choice] == 0u2; // line 3598
        upper[sampled_column_choice] = current_player; // line 3599
    } else { // line 3600
        if (sampled_row_choice == 1u2) { // line 3601
            observe middle[sampled_column_choice] == 0u2; // line 3602
            middle[sampled_column_choice] = current_player; // line 3603
        } else { // line 3604
            observe lower[sampled_column_choice] == 0u2; // line 3605
            lower[sampled_column_choice] = current_player; // line 3606
        } // line 3607
    } // line 3608
    row_choice = sampled_row_choice; // line 3609
    column_choice = sampled_column_choice; // line 3610
} // line 3611

expected_utility(u2 current_player) { // line 3613
    bool coin_flip; // line 3614
    u4 utility; // line 3615

    if (final_winner == current_player) { // line 3617
        utility = 10u4; // line 3618
    } else { // line 3619
        if (final_winner == 0u2) { // line 3620
        utility = 5u4; // line 3621
        } else { // line 3622
            utility = 1u4; // line 3623
        } // line 3624
    } // line 3625

    // outcome should range from 0 to 10 // line 3627
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 3628
    observe coin_flip; // line 3629
} // line 3630

winning_condition() { // line 3632
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 3633
        final_winner = upper[0u2]; // line 3634
    } else { // line 3635
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 3636
            final_winner = middle[0u2]; // line 3637
        } else { // line 3638
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 3639
                final_winner = lower[0u2]; // line 3640
            } else { // line 3641
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 3642
                    final_winner = upper[0u2]; // line 3643
                } else { // line 3644
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 3645
                        final_winner = upper[1u2]; // line 3646
                    } else { // line 3647
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 3648
                            final_winner = upper[2u2]; // line 3649
                        } else { // line 3650
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 3651
                                final_winner = upper[0u2]; // line 3652
                            } else { // line 3653
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 3654
                                    final_winner = upper[2u2]; // line 3655
                                } else { // line 3656
                                    final_winner = 0u2; // line 3657
                                } // line 3658
                            } // line 3659
                        } // line 3660
                    } // line 3661
                } // line 3662
            } // line 3663
        } // line 3664
    } // line 3665
} // line 3666
u2[3] upper; // line 3667
u2[3] middle; // line 3668
u2[3] lower; // line 3669
u2 final_winner; // line 3670

/*   // line 3672
    0 = non assigned // line 3673
    1 = circle (player 1) // line 3674
    2 = cross (player 2) // line 3675
    Initial Condition:  // line 3676
    |   | O |   | // line 3677
    | O | X | X | // line 3678
    |   | O |   | // line 3679
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 3680
*/  // line 3681

main (){ // line 3683
    u2 row_choice, column_choice; // line 3684
    upper[0u2] = 0u2; // line 3685
	upper[1u2] = 1u2; // line 3686
	upper[2u2] = 0u2; // line 3687
    middle[0u2] = 1u2; // line 3688
	middle[1u2] = 2u2; // line 3689
	middle[2u2] = 2u2; // line 3690
    lower[0u2] = 0u2; // line 3691
	lower[1u2] = 1u2; // line 3692
	lower[2u2] = 0u2; // line 3693

    final_winner = 0u2; // line 3695
    query sampleAction(2u2, row_choice, column_choice); // line 3696

} // line 3698

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3700
    bool another_turn; // line 3701
    u2 other_player; // line 3702
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 3703
    
    // sample a choice from the priori // line 3705
    query action_priori(current_player, row_choice, column_choice); // line 3706
    
    // is there a final_winner or is the grid filled? // line 3708
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3709
    winning_condition(); // line 3710

    // if nobody has won and there is another turn to play... // line 3712
    if (final_winner == 0u2 && another_turn) {     // line 3713
        // passing the turn // line 3714
        if (current_player == 1u2) { // line 3715
            other_player = 2u2; // line 3716
        } else { // line 3717
            other_player = 1u2; // line 3718
        } // line 3719
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 3720

    } else {} // line 3722

    // observing according to the utility of the outcome // line 3724
    expected_utility(current_player); // line 3725

    // returning row_choice and column_choice - the choice of the player // line 3727
} // line 3728


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3731
    u2 sampled_row_choice, sampled_column_choice; // line 3732

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3734
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3735

    // observe that the choice is feasible, and update the grid // line 3737
    if (sampled_row_choice == 0u2) { // line 3738
        observe upper[sampled_column_choice] == 0u2; // line 3739
        upper[sampled_column_choice] = current_player; // line 3740
    } else { // line 3741
        if (sampled_row_choice == 1u2) { // line 3742
            observe middle[sampled_column_choice] == 0u2; // line 3743
            middle[sampled_column_choice] = current_player; // line 3744
        } else { // line 3745
            observe lower[sampled_column_choice] == 0u2; // line 3746
            lower[sampled_column_choice] = current_player; // line 3747
        } // line 3748
    } // line 3749
    row_choice = sampled_row_choice; // line 3750
    column_choice = sampled_column_choice; // line 3751
} // line 3752

expected_utility(u2 current_player) { // line 3754
    bool coin_flip; // line 3755
    u4 utility; // line 3756

    if (final_winner == current_player) { // line 3758
        utility = 10u4; // line 3759
    } else { // line 3760
        if (final_winner == 0u2) { // line 3761
        utility = 5u4; // line 3762
        } else { // line 3763
            utility = 1u4; // line 3764
        } // line 3765
    } // line 3766

    // outcome should range from 0 to 10 // line 3768
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 3769
    observe coin_flip; // line 3770
} // line 3771

winning_condition() { // line 3773
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 3774
        final_winner = upper[0u2]; // line 3775
    } else { // line 3776
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 3777
            final_winner = middle[0u2]; // line 3778
        } else { // line 3779
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 3780
                final_winner = lower[0u2]; // line 3781
            } else { // line 3782
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 3783
                    final_winner = upper[0u2]; // line 3784
                } else { // line 3785
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 3786
                        final_winner = upper[1u2]; // line 3787
                    } else { // line 3788
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 3789
                            final_winner = upper[2u2]; // line 3790
                        } else { // line 3791
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 3792
                                final_winner = upper[0u2]; // line 3793
                            } else { // line 3794
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 3795
                                    final_winner = upper[2u2]; // line 3796
                                } else { // line 3797
                                    final_winner = 0u2; // line 3798
                                } // line 3799
                            } // line 3800
                        } // line 3801
                    } // line 3802
                } // line 3803
            } // line 3804
        } // line 3805
    } // line 3806
} // line 3807
u2[3] upper; // line 3808
u2[3] middle; // line 3809
u2[3] lower; // line 3810
u2 final_winner; // line 3811

/*   // line 3813
    0 = non assigned // line 3814
    1 = circle (player 1) // line 3815
    2 = cross (player 2) // line 3816
    Initial Condition:  // line 3817
    |   | O |   | // line 3818
    | O | X | X | // line 3819
    |   | O |   | // line 3820
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 3821
*/  // line 3822

main (){ // line 3824
    u2 row_choice, column_choice; // line 3825
    upper[0u2] = 0u2; // line 3826
	upper[1u2] = 1u2; // line 3827
	upper[2u2] = 0u2; // line 3828
    middle[0u2] = 1u2; // line 3829
	middle[1u2] = 2u2; // line 3830
	middle[2u2] = 2u2; // line 3831
    lower[0u2] = 0u2; // line 3832
	lower[1u2] = 1u2; // line 3833
	lower[2u2] = 0u2; // line 3834

    final_winner = 0u2; // line 3836
    query sampleAction(2u2, row_choice, column_choice); // line 3837

} // line 3839

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3841
    bool another_turn; // line 3842
    u2 other_player; // line 3843
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 3844
    
    // sample a choice from the priori // line 3846
    query action_priori(current_player, row_choice, column_choice); // line 3847
    
    // is there a final_winner or is the grid filled? // line 3849
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3850
    winning_condition(); // line 3851

    // if nobody has won and there is another turn to play... // line 3853
    if (final_winner == 0u2 && another_turn) {     // line 3854
        // passing the turn // line 3855
        if (current_player == 1u2) { // line 3856
            other_player = 2u2; // line 3857
        } else { // line 3858
            other_player = 1u2; // line 3859
        } // line 3860
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 3861

    } else {} // line 3863

    // observing according to the utility of the outcome // line 3865
    expected_utility(current_player); // line 3866

    // returning row_choice and column_choice - the choice of the player // line 3868
} // line 3869


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3872
    u2 sampled_row_choice, sampled_column_choice; // line 3873

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3875
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 3876

    // observe that the choice is feasible, and update the grid // line 3878
    if (sampled_row_choice == 0u2) { // line 3879
        observe upper[sampled_column_choice] == 0u2; // line 3880
        upper[sampled_column_choice] = current_player; // line 3881
    } else { // line 3882
        if (sampled_row_choice == 1u2) { // line 3883
            observe middle[sampled_column_choice] == 0u2; // line 3884
            middle[sampled_column_choice] = current_player; // line 3885
        } else { // line 3886
            observe lower[sampled_column_choice] == 0u2; // line 3887
            lower[sampled_column_choice] = current_player; // line 3888
        } // line 3889
    } // line 3890
    row_choice = sampled_row_choice; // line 3891
    column_choice = sampled_column_choice; // line 3892
} // line 3893

expected_utility(u2 current_player) { // line 3895
    bool coin_flip; // line 3896
    u4 utility; // line 3897

    if (final_winner == current_player) { // line 3899
        utility = 10u4; // line 3900
    } else { // line 3901
        if (final_winner == 0u2) { // line 3902
        utility = 5u4; // line 3903
        } else { // line 3904
            utility = 1u4; // line 3905
        } // line 3906
    } // line 3907

    // outcome should range from 0 to 10 // line 3909
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 3910
    observe coin_flip; // line 3911
} // line 3912

winning_condition() { // line 3914
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 3915
        final_winner = upper[0u2]; // line 3916
    } else { // line 3917
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 3918
            final_winner = middle[0u2]; // line 3919
        } else { // line 3920
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 3921
                final_winner = lower[0u2]; // line 3922
            } else { // line 3923
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 3924
                    final_winner = upper[0u2]; // line 3925
                } else { // line 3926
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 3927
                        final_winner = upper[1u2]; // line 3928
                    } else { // line 3929
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 3930
                            final_winner = upper[2u2]; // line 3931
                        } else { // line 3932
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 3933
                                final_winner = upper[0u2]; // line 3934
                            } else { // line 3935
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 3936
                                    final_winner = upper[2u2]; // line 3937
                                } else { // line 3938
                                    final_winner = 0u2; // line 3939
                                } // line 3940
                            } // line 3941
                        } // line 3942
                    } // line 3943
                } // line 3944
            } // line 3945
        } // line 3946
    } // line 3947
} // line 3948
u2[3] upper; // line 3949
u2[3] middle; // line 3950
u2[3] lower; // line 3951
u2 final_winner; // line 3952

/*   // line 3954
    0 = non assigned // line 3955
    1 = circle (player 1) // line 3956
    2 = cross (player 2) // line 3957
    Initial Condition:  // line 3958
    |   | O |   | // line 3959
    | O | X | X | // line 3960
    |   | O |   | // line 3961
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 3962
*/  // line 3963

main (){ // line 3965
    u2 row_choice, column_choice; // line 3966
    upper[0u2] = 0u2; // line 3967
	upper[1u2] = 1u2; // line 3968
	upper[2u2] = 0u2; // line 3969
    middle[0u2] = 1u2; // line 3970
	middle[1u2] = 2u2; // line 3971
	middle[2u2] = 2u2; // line 3972
    lower[0u2] = 0u2; // line 3973
	lower[1u2] = 1u2; // line 3974
	lower[2u2] = 0u2; // line 3975

    final_winner = 0u2; // line 3977
    query sampleAction(2u2, row_choice, column_choice); // line 3978

} // line 3980

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 3982
    bool another_turn; // line 3983
    u2 other_player; // line 3984
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 3985
    
    // sample a choice from the priori // line 3987
    query action_priori(current_player, row_choice, column_choice); // line 3988
    
    // is there a final_winner or is the grid filled? // line 3990
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 3991
    winning_condition(); // line 3992

    // if nobody has won and there is another turn to play... // line 3994
    if (final_winner == 0u2 && another_turn) {     // line 3995
        // passing the turn // line 3996
        if (current_player == 1u2) { // line 3997
            other_player = 2u2; // line 3998
        } else { // line 3999
            other_player = 1u2; // line 4000
        } // line 4001
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4002

    } else {} // line 4004

    // observing according to the utility of the outcome // line 4006
    expected_utility(current_player); // line 4007

    // returning row_choice and column_choice - the choice of the player // line 4009
} // line 4010


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4013
    u2 sampled_row_choice, sampled_column_choice; // line 4014

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4016
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4017

    // observe that the choice is feasible, and update the grid // line 4019
    if (sampled_row_choice == 0u2) { // line 4020
        observe upper[sampled_column_choice] == 0u2; // line 4021
        upper[sampled_column_choice] = current_player; // line 4022
    } else { // line 4023
        if (sampled_row_choice == 1u2) { // line 4024
            observe middle[sampled_column_choice] == 0u2; // line 4025
            middle[sampled_column_choice] = current_player; // line 4026
        } else { // line 4027
            observe lower[sampled_column_choice] == 0u2; // line 4028
            lower[sampled_column_choice] = current_player; // line 4029
        } // line 4030
    } // line 4031
    row_choice = sampled_row_choice; // line 4032
    column_choice = sampled_column_choice; // line 4033
} // line 4034

expected_utility(u2 current_player) { // line 4036
    bool coin_flip; // line 4037
    u4 utility; // line 4038

    if (final_winner == current_player) { // line 4040
        utility = 10u4; // line 4041
    } else { // line 4042
        if (final_winner == 0u2) { // line 4043
        utility = 5u4; // line 4044
        } else { // line 4045
            utility = 1u4; // line 4046
        } // line 4047
    } // line 4048

    // outcome should range from 0 to 10 // line 4050
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 4051
    observe coin_flip; // line 4052
} // line 4053

winning_condition() { // line 4055
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 4056
        final_winner = upper[0u2]; // line 4057
    } else { // line 4058
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 4059
            final_winner = middle[0u2]; // line 4060
        } else { // line 4061
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 4062
                final_winner = lower[0u2]; // line 4063
            } else { // line 4064
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 4065
                    final_winner = upper[0u2]; // line 4066
                } else { // line 4067
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 4068
                        final_winner = upper[1u2]; // line 4069
                    } else { // line 4070
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 4071
                            final_winner = upper[2u2]; // line 4072
                        } else { // line 4073
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 4074
                                final_winner = upper[0u2]; // line 4075
                            } else { // line 4076
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 4077
                                    final_winner = upper[2u2]; // line 4078
                                } else { // line 4079
                                    final_winner = 0u2; // line 4080
                                } // line 4081
                            } // line 4082
                        } // line 4083
                    } // line 4084
                } // line 4085
            } // line 4086
        } // line 4087
    } // line 4088
} // line 4089
u2[3] upper; // line 4090
u2[3] middle; // line 4091
u2[3] lower; // line 4092
u2 final_winner; // line 4093

/*   // line 4095
    0 = non assigned // line 4096
    1 = circle (player 1) // line 4097
    2 = cross (player 2) // line 4098
    Initial Condition:  // line 4099
    |   | O |   | // line 4100
    | O | X | X | // line 4101
    |   | O |   | // line 4102
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 4103
*/  // line 4104

main (){ // line 4106
    u2 row_choice, column_choice; // line 4107
    upper[0u2] = 0u2; // line 4108
	upper[1u2] = 1u2; // line 4109
	upper[2u2] = 0u2; // line 4110
    middle[0u2] = 1u2; // line 4111
	middle[1u2] = 2u2; // line 4112
	middle[2u2] = 2u2; // line 4113
    lower[0u2] = 0u2; // line 4114
	lower[1u2] = 1u2; // line 4115
	lower[2u2] = 0u2; // line 4116

    final_winner = 0u2; // line 4118
    query sampleAction(2u2, row_choice, column_choice); // line 4119

} // line 4121

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4123
    bool another_turn; // line 4124
    u2 other_player; // line 4125
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 4126
    
    // sample a choice from the priori // line 4128
    query action_priori(current_player, row_choice, column_choice); // line 4129
    
    // is there a final_winner or is the grid filled? // line 4131
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 4132
    winning_condition(); // line 4133

    // if nobody has won and there is another turn to play... // line 4135
    if (final_winner == 0u2 && another_turn) {     // line 4136
        // passing the turn // line 4137
        if (current_player == 1u2) { // line 4138
            other_player = 2u2; // line 4139
        } else { // line 4140
            other_player = 1u2; // line 4141
        } // line 4142
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4143

    } else {} // line 4145

    // observing according to the utility of the outcome // line 4147
    expected_utility(current_player); // line 4148

    // returning row_choice and column_choice - the choice of the player // line 4150
} // line 4151


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4154
    u2 sampled_row_choice, sampled_column_choice; // line 4155

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4157
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4158

    // observe that the choice is feasible, and update the grid // line 4160
    if (sampled_row_choice == 0u2) { // line 4161
        observe upper[sampled_column_choice] == 0u2; // line 4162
        upper[sampled_column_choice] = current_player; // line 4163
    } else { // line 4164
        if (sampled_row_choice == 1u2) { // line 4165
            observe middle[sampled_column_choice] == 0u2; // line 4166
            middle[sampled_column_choice] = current_player; // line 4167
        } else { // line 4168
            observe lower[sampled_column_choice] == 0u2; // line 4169
            lower[sampled_column_choice] = current_player; // line 4170
        } // line 4171
    } // line 4172
    row_choice = sampled_row_choice; // line 4173
    column_choice = sampled_column_choice; // line 4174
} // line 4175

expected_utility(u2 current_player) { // line 4177
    bool coin_flip; // line 4178
    u4 utility; // line 4179

    if (final_winner == current_player) { // line 4181
        utility = 10u4; // line 4182
    } else { // line 4183
        if (final_winner == 0u2) { // line 4184
        utility = 5u4; // line 4185
        } else { // line 4186
            utility = 1u4; // line 4187
        } // line 4188
    } // line 4189

    // outcome should range from 0 to 10 // line 4191
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 4192
    observe coin_flip; // line 4193
} // line 4194

winning_condition() { // line 4196
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 4197
        final_winner = upper[0u2]; // line 4198
    } else { // line 4199
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 4200
            final_winner = middle[0u2]; // line 4201
        } else { // line 4202
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 4203
                final_winner = lower[0u2]; // line 4204
            } else { // line 4205
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 4206
                    final_winner = upper[0u2]; // line 4207
                } else { // line 4208
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 4209
                        final_winner = upper[1u2]; // line 4210
                    } else { // line 4211
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 4212
                            final_winner = upper[2u2]; // line 4213
                        } else { // line 4214
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 4215
                                final_winner = upper[0u2]; // line 4216
                            } else { // line 4217
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 4218
                                    final_winner = upper[2u2]; // line 4219
                                } else { // line 4220
                                    final_winner = 0u2; // line 4221
                                } // line 4222
                            } // line 4223
                        } // line 4224
                    } // line 4225
                } // line 4226
            } // line 4227
        } // line 4228
    } // line 4229
} // line 4230
u2[3] upper; // line 4231
u2[3] middle; // line 4232
u2[3] lower; // line 4233
u2 final_winner; // line 4234

/*   // line 4236
    0 = non assigned // line 4237
    1 = circle (player 1) // line 4238
    2 = cross (player 2) // line 4239
    Initial Condition:  // line 4240
    |   | O |   | // line 4241
    | O | X | X | // line 4242
    |   | O |   | // line 4243
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 4244
*/  // line 4245

main (){ // line 4247
    u2 row_choice, column_choice; // line 4248
    upper[0u2] = 0u2; // line 4249
	upper[1u2] = 1u2; // line 4250
	upper[2u2] = 0u2; // line 4251
    middle[0u2] = 1u2; // line 4252
	middle[1u2] = 2u2; // line 4253
	middle[2u2] = 2u2; // line 4254
    lower[0u2] = 0u2; // line 4255
	lower[1u2] = 1u2; // line 4256
	lower[2u2] = 0u2; // line 4257

    final_winner = 0u2; // line 4259
    query sampleAction(2u2, row_choice, column_choice); // line 4260

} // line 4262

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4264
    bool another_turn; // line 4265
    u2 other_player; // line 4266
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 4267
    
    // sample a choice from the priori // line 4269
    query action_priori(current_player, row_choice, column_choice); // line 4270
    
    // is there a final_winner or is the grid filled? // line 4272
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 4273
    winning_condition(); // line 4274

    // if nobody has won and there is another turn to play... // line 4276
    if (final_winner == 0u2 && another_turn) {     // line 4277
        // passing the turn // line 4278
        if (current_player == 1u2) { // line 4279
            other_player = 2u2; // line 4280
        } else { // line 4281
            other_player = 1u2; // line 4282
        } // line 4283
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4284

    } else {} // line 4286

    // observing according to the utility of the outcome // line 4288
    expected_utility(current_player); // line 4289

    // returning row_choice and column_choice - the choice of the player // line 4291
} // line 4292


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4295
    u2 sampled_row_choice, sampled_column_choice; // line 4296

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4298
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4299

    // observe that the choice is feasible, and update the grid // line 4301
    if (sampled_row_choice == 0u2) { // line 4302
        observe upper[sampled_column_choice] == 0u2; // line 4303
        upper[sampled_column_choice] = current_player; // line 4304
    } else { // line 4305
        if (sampled_row_choice == 1u2) { // line 4306
            observe middle[sampled_column_choice] == 0u2; // line 4307
            middle[sampled_column_choice] = current_player; // line 4308
        } else { // line 4309
            observe lower[sampled_column_choice] == 0u2; // line 4310
            lower[sampled_column_choice] = current_player; // line 4311
        } // line 4312
    } // line 4313
    row_choice = sampled_row_choice; // line 4314
    column_choice = sampled_column_choice; // line 4315
} // line 4316

expected_utility(u2 current_player) { // line 4318
    bool coin_flip; // line 4319
    u4 utility; // line 4320

    if (final_winner == current_player) { // line 4322
        utility = 10u4; // line 4323
    } else { // line 4324
        if (final_winner == 0u2) { // line 4325
        utility = 5u4; // line 4326
        } else { // line 4327
            utility = 1u4; // line 4328
        } // line 4329
    } // line 4330

    // outcome should range from 0 to 10 // line 4332
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 4333
    observe coin_flip; // line 4334
} // line 4335

winning_condition() { // line 4337
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 4338
        final_winner = upper[0u2]; // line 4339
    } else { // line 4340
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 4341
            final_winner = middle[0u2]; // line 4342
        } else { // line 4343
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 4344
                final_winner = lower[0u2]; // line 4345
            } else { // line 4346
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 4347
                    final_winner = upper[0u2]; // line 4348
                } else { // line 4349
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 4350
                        final_winner = upper[1u2]; // line 4351
                    } else { // line 4352
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 4353
                            final_winner = upper[2u2]; // line 4354
                        } else { // line 4355
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 4356
                                final_winner = upper[0u2]; // line 4357
                            } else { // line 4358
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 4359
                                    final_winner = upper[2u2]; // line 4360
                                } else { // line 4361
                                    final_winner = 0u2; // line 4362
                                } // line 4363
                            } // line 4364
                        } // line 4365
                    } // line 4366
                } // line 4367
            } // line 4368
        } // line 4369
    } // line 4370
} // line 4371
u2[3] upper; // line 4372
u2[3] middle; // line 4373
u2[3] lower; // line 4374
u2 final_winner; // line 4375

/*   // line 4377
    0 = non assigned // line 4378
    1 = circle (player 1) // line 4379
    2 = cross (player 2) // line 4380
    Initial Condition:  // line 4381
    |   | O |   | // line 4382
    | O | X | X | // line 4383
    |   | O |   | // line 4384
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 4385
*/  // line 4386

main (){ // line 4388
    u2 row_choice, column_choice; // line 4389
    upper[0u2] = 0u2; // line 4390
	upper[1u2] = 1u2; // line 4391
	upper[2u2] = 0u2; // line 4392
    middle[0u2] = 1u2; // line 4393
	middle[1u2] = 2u2; // line 4394
	middle[2u2] = 2u2; // line 4395
    lower[0u2] = 0u2; // line 4396
	lower[1u2] = 1u2; // line 4397
	lower[2u2] = 0u2; // line 4398

    final_winner = 0u2; // line 4400
    query sampleAction(2u2, row_choice, column_choice); // line 4401

} // line 4403

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4405
    bool another_turn; // line 4406
    u2 other_player; // line 4407
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 4408
    
    // sample a choice from the priori // line 4410
    query action_priori(current_player, row_choice, column_choice); // line 4411
    
    // is there a final_winner or is the grid filled? // line 4413
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 4414
    winning_condition(); // line 4415

    // if nobody has won and there is another turn to play... // line 4417
    if (final_winner == 0u2 && another_turn) {     // line 4418
        // passing the turn // line 4419
        if (current_player == 1u2) { // line 4420
            other_player = 2u2; // line 4421
        } else { // line 4422
            other_player = 1u2; // line 4423
        } // line 4424
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4425

    } else {} // line 4427

    // observing according to the utility of the outcome // line 4429
    expected_utility(current_player); // line 4430

    // returning row_choice and column_choice - the choice of the player // line 4432
} // line 4433


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4436
    u2 sampled_row_choice, sampled_column_choice; // line 4437

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4439
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4440

    // observe that the choice is feasible, and update the grid // line 4442
    if (sampled_row_choice == 0u2) { // line 4443
        observe upper[sampled_column_choice] == 0u2; // line 4444
        upper[sampled_column_choice] = current_player; // line 4445
    } else { // line 4446
        if (sampled_row_choice == 1u2) { // line 4447
            observe middle[sampled_column_choice] == 0u2; // line 4448
            middle[sampled_column_choice] = current_player; // line 4449
        } else { // line 4450
            observe lower[sampled_column_choice] == 0u2; // line 4451
            lower[sampled_column_choice] = current_player; // line 4452
        } // line 4453
    } // line 4454
    row_choice = sampled_row_choice; // line 4455
    column_choice = sampled_column_choice; // line 4456
} // line 4457

expected_utility(u2 current_player) { // line 4459
    bool coin_flip; // line 4460
    u4 utility; // line 4461

    if (final_winner == current_player) { // line 4463
        utility = 10u4; // line 4464
    } else { // line 4465
        if (final_winner == 0u2) { // line 4466
        utility = 5u4; // line 4467
        } else { // line 4468
            utility = 1u4; // line 4469
        } // line 4470
    } // line 4471

    // outcome should range from 0 to 10 // line 4473
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 4474
    observe coin_flip; // line 4475
} // line 4476

winning_condition() { // line 4478
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 4479
        final_winner = upper[0u2]; // line 4480
    } else { // line 4481
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 4482
            final_winner = middle[0u2]; // line 4483
        } else { // line 4484
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 4485
                final_winner = lower[0u2]; // line 4486
            } else { // line 4487
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 4488
                    final_winner = upper[0u2]; // line 4489
                } else { // line 4490
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 4491
                        final_winner = upper[1u2]; // line 4492
                    } else { // line 4493
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 4494
                            final_winner = upper[2u2]; // line 4495
                        } else { // line 4496
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 4497
                                final_winner = upper[0u2]; // line 4498
                            } else { // line 4499
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 4500
                                    final_winner = upper[2u2]; // line 4501
                                } else { // line 4502
                                    final_winner = 0u2; // line 4503
                                } // line 4504
                            } // line 4505
                        } // line 4506
                    } // line 4507
                } // line 4508
            } // line 4509
        } // line 4510
    } // line 4511
} // line 4512
u2[3] upper; // line 4513
u2[3] middle; // line 4514
u2[3] lower; // line 4515
u2 final_winner; // line 4516

/*   // line 4518
    0 = non assigned // line 4519
    1 = circle (player 1) // line 4520
    2 = cross (player 2) // line 4521
    Initial Condition:  // line 4522
    |   | O |   | // line 4523
    | O | X | X | // line 4524
    |   | O |   | // line 4525
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 4526
*/  // line 4527

main (){ // line 4529
    u2 row_choice, column_choice; // line 4530
    upper[0u2] = 0u2; // line 4531
	upper[1u2] = 1u2; // line 4532
	upper[2u2] = 0u2; // line 4533
    middle[0u2] = 1u2; // line 4534
	middle[1u2] = 2u2; // line 4535
	middle[2u2] = 2u2; // line 4536
    lower[0u2] = 0u2; // line 4537
	lower[1u2] = 1u2; // line 4538
	lower[2u2] = 0u2; // line 4539

    final_winner = 0u2; // line 4541
    query sampleAction(2u2, row_choice, column_choice); // line 4542

} // line 4544

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4546
    bool another_turn; // line 4547
    u2 other_player; // line 4548
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 4549
    
    // sample a choice from the priori // line 4551
    query action_priori(current_player, row_choice, column_choice); // line 4552
    
    // is there a final_winner or is the grid filled? // line 4554
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 4555
    winning_condition(); // line 4556

    // if nobody has won and there is another turn to play... // line 4558
    if (final_winner == 0u2 && another_turn) {     // line 4559
        // passing the turn // line 4560
        if (current_player == 1u2) { // line 4561
            other_player = 2u2; // line 4562
        } else { // line 4563
            other_player = 1u2; // line 4564
        } // line 4565
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4566

    } else {} // line 4568

    // observing according to the utility of the outcome // line 4570
    expected_utility(current_player); // line 4571

    // returning row_choice and column_choice - the choice of the player // line 4573
} // line 4574


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4577
    u2 sampled_row_choice, sampled_column_choice; // line 4578

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4580
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4581

    // observe that the choice is feasible, and update the grid // line 4583
    if (sampled_row_choice == 0u2) { // line 4584
        observe upper[sampled_column_choice] == 0u2; // line 4585
        upper[sampled_column_choice] = current_player; // line 4586
    } else { // line 4587
        if (sampled_row_choice == 1u2) { // line 4588
            observe middle[sampled_column_choice] == 0u2; // line 4589
            middle[sampled_column_choice] = current_player; // line 4590
        } else { // line 4591
            observe lower[sampled_column_choice] == 0u2; // line 4592
            lower[sampled_column_choice] = current_player; // line 4593
        } // line 4594
    } // line 4595
    row_choice = sampled_row_choice; // line 4596
    column_choice = sampled_column_choice; // line 4597
} // line 4598

expected_utility(u2 current_player) { // line 4600
    bool coin_flip; // line 4601
    u4 utility; // line 4602

    if (final_winner == current_player) { // line 4604
        utility = 10u4; // line 4605
    } else { // line 4606
        if (final_winner == 0u2) { // line 4607
        utility = 5u4; // line 4608
        } else { // line 4609
            utility = 1u4; // line 4610
        } // line 4611
    } // line 4612

    // outcome should range from 0 to 10 // line 4614
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 4615
    observe coin_flip; // line 4616
} // line 4617

winning_condition() { // line 4619
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 4620
        final_winner = upper[0u2]; // line 4621
    } else { // line 4622
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 4623
            final_winner = middle[0u2]; // line 4624
        } else { // line 4625
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 4626
                final_winner = lower[0u2]; // line 4627
            } else { // line 4628
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 4629
                    final_winner = upper[0u2]; // line 4630
                } else { // line 4631
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 4632
                        final_winner = upper[1u2]; // line 4633
                    } else { // line 4634
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 4635
                            final_winner = upper[2u2]; // line 4636
                        } else { // line 4637
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 4638
                                final_winner = upper[0u2]; // line 4639
                            } else { // line 4640
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 4641
                                    final_winner = upper[2u2]; // line 4642
                                } else { // line 4643
                                    final_winner = 0u2; // line 4644
                                } // line 4645
                            } // line 4646
                        } // line 4647
                    } // line 4648
                } // line 4649
            } // line 4650
        } // line 4651
    } // line 4652
} // line 4653
u2[3] upper; // line 4654
u2[3] middle; // line 4655
u2[3] lower; // line 4656
u2 final_winner; // line 4657

/*   // line 4659
    0 = non assigned // line 4660
    1 = circle (player 1) // line 4661
    2 = cross (player 2) // line 4662
    Initial Condition:  // line 4663
    |   | O |   | // line 4664
    | O | X | X | // line 4665
    |   | O |   | // line 4666
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 4667
*/  // line 4668

main (){ // line 4670
    u2 row_choice, column_choice; // line 4671
    upper[0u2] = 0u2; // line 4672
	upper[1u2] = 1u2; // line 4673
	upper[2u2] = 0u2; // line 4674
    middle[0u2] = 1u2; // line 4675
	middle[1u2] = 2u2; // line 4676
	middle[2u2] = 2u2; // line 4677
    lower[0u2] = 0u2; // line 4678
	lower[1u2] = 1u2; // line 4679
	lower[2u2] = 0u2; // line 4680

    final_winner = 0u2; // line 4682
    query sampleAction(2u2, row_choice, column_choice); // line 4683

} // line 4685

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4687
    bool another_turn; // line 4688
    u2 other_player; // line 4689
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 4690
    
    // sample a choice from the priori // line 4692
    query action_priori(current_player, row_choice, column_choice); // line 4693
    
    // is there a final_winner or is the grid filled? // line 4695
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 4696
    winning_condition(); // line 4697

    // if nobody has won and there is another turn to play... // line 4699
    if (final_winner == 0u2 && another_turn) {     // line 4700
        // passing the turn // line 4701
        if (current_player == 1u2) { // line 4702
            other_player = 2u2; // line 4703
        } else { // line 4704
            other_player = 1u2; // line 4705
        } // line 4706
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4707

    } else {} // line 4709

    // observing according to the utility of the outcome // line 4711
    expected_utility(current_player); // line 4712

    // returning row_choice and column_choice - the choice of the player // line 4714
} // line 4715


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4718
    u2 sampled_row_choice, sampled_column_choice; // line 4719

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4721
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4722

    // observe that the choice is feasible, and update the grid // line 4724
    if (sampled_row_choice == 0u2) { // line 4725
        observe upper[sampled_column_choice] == 0u2; // line 4726
        upper[sampled_column_choice] = current_player; // line 4727
    } else { // line 4728
        if (sampled_row_choice == 1u2) { // line 4729
            observe middle[sampled_column_choice] == 0u2; // line 4730
            middle[sampled_column_choice] = current_player; // line 4731
        } else { // line 4732
            observe lower[sampled_column_choice] == 0u2; // line 4733
            lower[sampled_column_choice] = current_player; // line 4734
        } // line 4735
    } // line 4736
    row_choice = sampled_row_choice; // line 4737
    column_choice = sampled_column_choice; // line 4738
} // line 4739

expected_utility(u2 current_player) { // line 4741
    bool coin_flip; // line 4742
    u4 utility; // line 4743

    if (final_winner == current_player) { // line 4745
        utility = 10u4; // line 4746
    } else { // line 4747
        if (final_winner == 0u2) { // line 4748
        utility = 5u4; // line 4749
        } else { // line 4750
            utility = 1u4; // line 4751
        } // line 4752
    } // line 4753

    // outcome should range from 0 to 10 // line 4755
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 4756
    observe coin_flip; // line 4757
} // line 4758

winning_condition() { // line 4760
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 4761
        final_winner = upper[0u2]; // line 4762
    } else { // line 4763
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 4764
            final_winner = middle[0u2]; // line 4765
        } else { // line 4766
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 4767
                final_winner = lower[0u2]; // line 4768
            } else { // line 4769
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 4770
                    final_winner = upper[0u2]; // line 4771
                } else { // line 4772
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 4773
                        final_winner = upper[1u2]; // line 4774
                    } else { // line 4775
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 4776
                            final_winner = upper[2u2]; // line 4777
                        } else { // line 4778
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 4779
                                final_winner = upper[0u2]; // line 4780
                            } else { // line 4781
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 4782
                                    final_winner = upper[2u2]; // line 4783
                                } else { // line 4784
                                    final_winner = 0u2; // line 4785
                                } // line 4786
                            } // line 4787
                        } // line 4788
                    } // line 4789
                } // line 4790
            } // line 4791
        } // line 4792
    } // line 4793
} // line 4794
u2[3] upper; // line 4795
u2[3] middle; // line 4796
u2[3] lower; // line 4797
u2 final_winner; // line 4798

/*   // line 4800
    0 = non assigned // line 4801
    1 = circle (player 1) // line 4802
    2 = cross (player 2) // line 4803
    Initial Condition:  // line 4804
    |   | O |   | // line 4805
    | O | X | X | // line 4806
    |   | O |   | // line 4807
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 4808
*/  // line 4809

main (){ // line 4811
    u2 row_choice, column_choice; // line 4812
    upper[0u2] = 0u2; // line 4813
	upper[1u2] = 1u2; // line 4814
	upper[2u2] = 0u2; // line 4815
    middle[0u2] = 1u2; // line 4816
	middle[1u2] = 2u2; // line 4817
	middle[2u2] = 2u2; // line 4818
    lower[0u2] = 0u2; // line 4819
	lower[1u2] = 1u2; // line 4820
	lower[2u2] = 0u2; // line 4821

    final_winner = 0u2; // line 4823
    query sampleAction(2u2, row_choice, column_choice); // line 4824

} // line 4826

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4828
    bool another_turn; // line 4829
    u2 other_player; // line 4830
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 4831
    
    // sample a choice from the priori // line 4833
    query action_priori(current_player, row_choice, column_choice); // line 4834
    
    // is there a final_winner or is the grid filled? // line 4836
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 4837
    winning_condition(); // line 4838

    // if nobody has won and there is another turn to play... // line 4840
    if (final_winner == 0u2 && another_turn) {     // line 4841
        // passing the turn // line 4842
        if (current_player == 1u2) { // line 4843
            other_player = 2u2; // line 4844
        } else { // line 4845
            other_player = 1u2; // line 4846
        } // line 4847
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4848

    } else {} // line 4850

    // observing according to the utility of the outcome // line 4852
    expected_utility(current_player); // line 4853

    // returning row_choice and column_choice - the choice of the player // line 4855
} // line 4856


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4859
    u2 sampled_row_choice, sampled_column_choice; // line 4860

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4862
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 4863

    // observe that the choice is feasible, and update the grid // line 4865
    if (sampled_row_choice == 0u2) { // line 4866
        observe upper[sampled_column_choice] == 0u2; // line 4867
        upper[sampled_column_choice] = current_player; // line 4868
    } else { // line 4869
        if (sampled_row_choice == 1u2) { // line 4870
            observe middle[sampled_column_choice] == 0u2; // line 4871
            middle[sampled_column_choice] = current_player; // line 4872
        } else { // line 4873
            observe lower[sampled_column_choice] == 0u2; // line 4874
            lower[sampled_column_choice] = current_player; // line 4875
        } // line 4876
    } // line 4877
    row_choice = sampled_row_choice; // line 4878
    column_choice = sampled_column_choice; // line 4879
} // line 4880

expected_utility(u2 current_player) { // line 4882
    bool coin_flip; // line 4883
    u4 utility; // line 4884

    if (final_winner == current_player) { // line 4886
        utility = 10u4; // line 4887
    } else { // line 4888
        if (final_winner == 0u2) { // line 4889
        utility = 5u4; // line 4890
        } else { // line 4891
            utility = 1u4; // line 4892
        } // line 4893
    } // line 4894

    // outcome should range from 0 to 10 // line 4896
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 4897
    observe coin_flip; // line 4898
} // line 4899

winning_condition() { // line 4901
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 4902
        final_winner = upper[0u2]; // line 4903
    } else { // line 4904
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 4905
            final_winner = middle[0u2]; // line 4906
        } else { // line 4907
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 4908
                final_winner = lower[0u2]; // line 4909
            } else { // line 4910
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 4911
                    final_winner = upper[0u2]; // line 4912
                } else { // line 4913
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 4914
                        final_winner = upper[1u2]; // line 4915
                    } else { // line 4916
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 4917
                            final_winner = upper[2u2]; // line 4918
                        } else { // line 4919
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 4920
                                final_winner = upper[0u2]; // line 4921
                            } else { // line 4922
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 4923
                                    final_winner = upper[2u2]; // line 4924
                                } else { // line 4925
                                    final_winner = 0u2; // line 4926
                                } // line 4927
                            } // line 4928
                        } // line 4929
                    } // line 4930
                } // line 4931
            } // line 4932
        } // line 4933
    } // line 4934
} // line 4935
u2[3] upper; // line 4936
u2[3] middle; // line 4937
u2[3] lower; // line 4938
u2 final_winner; // line 4939

/*   // line 4941
    0 = non assigned // line 4942
    1 = circle (player 1) // line 4943
    2 = cross (player 2) // line 4944
    Initial Condition:  // line 4945
    |   | O |   | // line 4946
    | O | X | X | // line 4947
    |   | O |   | // line 4948
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 4949
*/  // line 4950

main (){ // line 4952
    u2 row_choice, column_choice; // line 4953
    upper[0u2] = 0u2; // line 4954
	upper[1u2] = 1u2; // line 4955
	upper[2u2] = 0u2; // line 4956
    middle[0u2] = 1u2; // line 4957
	middle[1u2] = 2u2; // line 4958
	middle[2u2] = 2u2; // line 4959
    lower[0u2] = 0u2; // line 4960
	lower[1u2] = 1u2; // line 4961
	lower[2u2] = 0u2; // line 4962

    final_winner = 0u2; // line 4964
    query sampleAction(2u2, row_choice, column_choice); // line 4965

} // line 4967

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 4969
    bool another_turn; // line 4970
    u2 other_player; // line 4971
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 4972
    
    // sample a choice from the priori // line 4974
    query action_priori(current_player, row_choice, column_choice); // line 4975
    
    // is there a final_winner or is the grid filled? // line 4977
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 4978
    winning_condition(); // line 4979

    // if nobody has won and there is another turn to play... // line 4981
    if (final_winner == 0u2 && another_turn) {     // line 4982
        // passing the turn // line 4983
        if (current_player == 1u2) { // line 4984
            other_player = 2u2; // line 4985
        } else { // line 4986
            other_player = 1u2; // line 4987
        } // line 4988
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 4989

    } else {} // line 4991

    // observing according to the utility of the outcome // line 4993
    expected_utility(current_player); // line 4994

    // returning row_choice and column_choice - the choice of the player // line 4996
} // line 4997


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5000
    u2 sampled_row_choice, sampled_column_choice; // line 5001

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5003
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5004

    // observe that the choice is feasible, and update the grid // line 5006
    if (sampled_row_choice == 0u2) { // line 5007
        observe upper[sampled_column_choice] == 0u2; // line 5008
        upper[sampled_column_choice] = current_player; // line 5009
    } else { // line 5010
        if (sampled_row_choice == 1u2) { // line 5011
            observe middle[sampled_column_choice] == 0u2; // line 5012
            middle[sampled_column_choice] = current_player; // line 5013
        } else { // line 5014
            observe lower[sampled_column_choice] == 0u2; // line 5015
            lower[sampled_column_choice] = current_player; // line 5016
        } // line 5017
    } // line 5018
    row_choice = sampled_row_choice; // line 5019
    column_choice = sampled_column_choice; // line 5020
} // line 5021

expected_utility(u2 current_player) { // line 5023
    bool coin_flip; // line 5024
    u4 utility; // line 5025

    if (final_winner == current_player) { // line 5027
        utility = 10u4; // line 5028
    } else { // line 5029
        if (final_winner == 0u2) { // line 5030
        utility = 5u4; // line 5031
        } else { // line 5032
            utility = 1u4; // line 5033
        } // line 5034
    } // line 5035

    // outcome should range from 0 to 10 // line 5037
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 5038
    observe coin_flip; // line 5039
} // line 5040

winning_condition() { // line 5042
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 5043
        final_winner = upper[0u2]; // line 5044
    } else { // line 5045
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 5046
            final_winner = middle[0u2]; // line 5047
        } else { // line 5048
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 5049
                final_winner = lower[0u2]; // line 5050
            } else { // line 5051
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 5052
                    final_winner = upper[0u2]; // line 5053
                } else { // line 5054
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 5055
                        final_winner = upper[1u2]; // line 5056
                    } else { // line 5057
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 5058
                            final_winner = upper[2u2]; // line 5059
                        } else { // line 5060
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 5061
                                final_winner = upper[0u2]; // line 5062
                            } else { // line 5063
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 5064
                                    final_winner = upper[2u2]; // line 5065
                                } else { // line 5066
                                    final_winner = 0u2; // line 5067
                                } // line 5068
                            } // line 5069
                        } // line 5070
                    } // line 5071
                } // line 5072
            } // line 5073
        } // line 5074
    } // line 5075
} // line 5076
u2[3] upper; // line 5077
u2[3] middle; // line 5078
u2[3] lower; // line 5079
u2 final_winner; // line 5080

/*   // line 5082
    0 = non assigned // line 5083
    1 = circle (player 1) // line 5084
    2 = cross (player 2) // line 5085
    Initial Condition:  // line 5086
    |   | O |   | // line 5087
    | O | X | X | // line 5088
    |   | O |   | // line 5089
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 5090
*/  // line 5091

main (){ // line 5093
    u2 row_choice, column_choice; // line 5094
    upper[0u2] = 0u2; // line 5095
	upper[1u2] = 1u2; // line 5096
	upper[2u2] = 0u2; // line 5097
    middle[0u2] = 1u2; // line 5098
	middle[1u2] = 2u2; // line 5099
	middle[2u2] = 2u2; // line 5100
    lower[0u2] = 0u2; // line 5101
	lower[1u2] = 1u2; // line 5102
	lower[2u2] = 0u2; // line 5103

    final_winner = 0u2; // line 5105
    query sampleAction(2u2, row_choice, column_choice); // line 5106

} // line 5108

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5110
    bool another_turn; // line 5111
    u2 other_player; // line 5112
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 5113
    
    // sample a choice from the priori // line 5115
    query action_priori(current_player, row_choice, column_choice); // line 5116
    
    // is there a final_winner or is the grid filled? // line 5118
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 5119
    winning_condition(); // line 5120

    // if nobody has won and there is another turn to play... // line 5122
    if (final_winner == 0u2 && another_turn) {     // line 5123
        // passing the turn // line 5124
        if (current_player == 1u2) { // line 5125
            other_player = 2u2; // line 5126
        } else { // line 5127
            other_player = 1u2; // line 5128
        } // line 5129
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 5130

    } else {} // line 5132

    // observing according to the utility of the outcome // line 5134
    expected_utility(current_player); // line 5135

    // returning row_choice and column_choice - the choice of the player // line 5137
} // line 5138


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5141
    u2 sampled_row_choice, sampled_column_choice; // line 5142

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5144
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5145

    // observe that the choice is feasible, and update the grid // line 5147
    if (sampled_row_choice == 0u2) { // line 5148
        observe upper[sampled_column_choice] == 0u2; // line 5149
        upper[sampled_column_choice] = current_player; // line 5150
    } else { // line 5151
        if (sampled_row_choice == 1u2) { // line 5152
            observe middle[sampled_column_choice] == 0u2; // line 5153
            middle[sampled_column_choice] = current_player; // line 5154
        } else { // line 5155
            observe lower[sampled_column_choice] == 0u2; // line 5156
            lower[sampled_column_choice] = current_player; // line 5157
        } // line 5158
    } // line 5159
    row_choice = sampled_row_choice; // line 5160
    column_choice = sampled_column_choice; // line 5161
} // line 5162

expected_utility(u2 current_player) { // line 5164
    bool coin_flip; // line 5165
    u4 utility; // line 5166

    if (final_winner == current_player) { // line 5168
        utility = 10u4; // line 5169
    } else { // line 5170
        if (final_winner == 0u2) { // line 5171
        utility = 5u4; // line 5172
        } else { // line 5173
            utility = 1u4; // line 5174
        } // line 5175
    } // line 5176

    // outcome should range from 0 to 10 // line 5178
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 5179
    observe coin_flip; // line 5180
} // line 5181

winning_condition() { // line 5183
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 5184
        final_winner = upper[0u2]; // line 5185
    } else { // line 5186
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 5187
            final_winner = middle[0u2]; // line 5188
        } else { // line 5189
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 5190
                final_winner = lower[0u2]; // line 5191
            } else { // line 5192
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 5193
                    final_winner = upper[0u2]; // line 5194
                } else { // line 5195
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 5196
                        final_winner = upper[1u2]; // line 5197
                    } else { // line 5198
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 5199
                            final_winner = upper[2u2]; // line 5200
                        } else { // line 5201
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 5202
                                final_winner = upper[0u2]; // line 5203
                            } else { // line 5204
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 5205
                                    final_winner = upper[2u2]; // line 5206
                                } else { // line 5207
                                    final_winner = 0u2; // line 5208
                                } // line 5209
                            } // line 5210
                        } // line 5211
                    } // line 5212
                } // line 5213
            } // line 5214
        } // line 5215
    } // line 5216
} // line 5217
u2[3] upper; // line 5218
u2[3] middle; // line 5219
u2[3] lower; // line 5220
u2 final_winner; // line 5221

/*   // line 5223
    0 = non assigned // line 5224
    1 = circle (player 1) // line 5225
    2 = cross (player 2) // line 5226
    Initial Condition:  // line 5227
    |   | O |   | // line 5228
    | O | X | X | // line 5229
    |   | O |   | // line 5230
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 5231
*/  // line 5232

main (){ // line 5234
    u2 row_choice, column_choice; // line 5235
    upper[0u2] = 0u2; // line 5236
	upper[1u2] = 1u2; // line 5237
	upper[2u2] = 0u2; // line 5238
    middle[0u2] = 1u2; // line 5239
	middle[1u2] = 2u2; // line 5240
	middle[2u2] = 2u2; // line 5241
    lower[0u2] = 0u2; // line 5242
	lower[1u2] = 1u2; // line 5243
	lower[2u2] = 0u2; // line 5244

    final_winner = 0u2; // line 5246
    query sampleAction(2u2, row_choice, column_choice); // line 5247

} // line 5249

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5251
    bool another_turn; // line 5252
    u2 other_player; // line 5253
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 5254
    
    // sample a choice from the priori // line 5256
    query action_priori(current_player, row_choice, column_choice); // line 5257
    
    // is there a final_winner or is the grid filled? // line 5259
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 5260
    winning_condition(); // line 5261

    // if nobody has won and there is another turn to play... // line 5263
    if (final_winner == 0u2 && another_turn) {     // line 5264
        // passing the turn // line 5265
        if (current_player == 1u2) { // line 5266
            other_player = 2u2; // line 5267
        } else { // line 5268
            other_player = 1u2; // line 5269
        } // line 5270
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 5271

    } else {} // line 5273

    // observing according to the utility of the outcome // line 5275
    expected_utility(current_player); // line 5276

    // returning row_choice and column_choice - the choice of the player // line 5278
} // line 5279


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5282
    u2 sampled_row_choice, sampled_column_choice; // line 5283

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5285
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5286

    // observe that the choice is feasible, and update the grid // line 5288
    if (sampled_row_choice == 0u2) { // line 5289
        observe upper[sampled_column_choice] == 0u2; // line 5290
        upper[sampled_column_choice] = current_player; // line 5291
    } else { // line 5292
        if (sampled_row_choice == 1u2) { // line 5293
            observe middle[sampled_column_choice] == 0u2; // line 5294
            middle[sampled_column_choice] = current_player; // line 5295
        } else { // line 5296
            observe lower[sampled_column_choice] == 0u2; // line 5297
            lower[sampled_column_choice] = current_player; // line 5298
        } // line 5299
    } // line 5300
    row_choice = sampled_row_choice; // line 5301
    column_choice = sampled_column_choice; // line 5302
} // line 5303

expected_utility(u2 current_player) { // line 5305
    bool coin_flip; // line 5306
    u4 utility; // line 5307

    if (final_winner == current_player) { // line 5309
        utility = 10u4; // line 5310
    } else { // line 5311
        if (final_winner == 0u2) { // line 5312
        utility = 5u4; // line 5313
        } else { // line 5314
            utility = 1u4; // line 5315
        } // line 5316
    } // line 5317

    // outcome should range from 0 to 10 // line 5319
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 5320
    observe coin_flip; // line 5321
} // line 5322

winning_condition() { // line 5324
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 5325
        final_winner = upper[0u2]; // line 5326
    } else { // line 5327
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 5328
            final_winner = middle[0u2]; // line 5329
        } else { // line 5330
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 5331
                final_winner = lower[0u2]; // line 5332
            } else { // line 5333
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 5334
                    final_winner = upper[0u2]; // line 5335
                } else { // line 5336
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 5337
                        final_winner = upper[1u2]; // line 5338
                    } else { // line 5339
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 5340
                            final_winner = upper[2u2]; // line 5341
                        } else { // line 5342
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 5343
                                final_winner = upper[0u2]; // line 5344
                            } else { // line 5345
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 5346
                                    final_winner = upper[2u2]; // line 5347
                                } else { // line 5348
                                    final_winner = 0u2; // line 5349
                                } // line 5350
                            } // line 5351
                        } // line 5352
                    } // line 5353
                } // line 5354
            } // line 5355
        } // line 5356
    } // line 5357
} // line 5358
u2[3] upper; // line 5359
u2[3] middle; // line 5360
u2[3] lower; // line 5361
u2 final_winner; // line 5362

/*   // line 5364
    0 = non assigned // line 5365
    1 = circle (player 1) // line 5366
    2 = cross (player 2) // line 5367
    Initial Condition:  // line 5368
    |   | O |   | // line 5369
    | O | X | X | // line 5370
    |   | O |   | // line 5371
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 5372
*/  // line 5373

main (){ // line 5375
    u2 row_choice, column_choice; // line 5376
    upper[0u2] = 0u2; // line 5377
	upper[1u2] = 1u2; // line 5378
	upper[2u2] = 0u2; // line 5379
    middle[0u2] = 1u2; // line 5380
	middle[1u2] = 2u2; // line 5381
	middle[2u2] = 2u2; // line 5382
    lower[0u2] = 0u2; // line 5383
	lower[1u2] = 1u2; // line 5384
	lower[2u2] = 0u2; // line 5385

    final_winner = 0u2; // line 5387
    query sampleAction(2u2, row_choice, column_choice); // line 5388

} // line 5390

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5392
    bool another_turn; // line 5393
    u2 other_player; // line 5394
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 5395
    
    // sample a choice from the priori // line 5397
    query action_priori(current_player, row_choice, column_choice); // line 5398
    
    // is there a final_winner or is the grid filled? // line 5400
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 5401
    winning_condition(); // line 5402

    // if nobody has won and there is another turn to play... // line 5404
    if (final_winner == 0u2 && another_turn) {     // line 5405
        // passing the turn // line 5406
        if (current_player == 1u2) { // line 5407
            other_player = 2u2; // line 5408
        } else { // line 5409
            other_player = 1u2; // line 5410
        } // line 5411
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 5412

    } else {} // line 5414

    // observing according to the utility of the outcome // line 5416
    expected_utility(current_player); // line 5417

    // returning row_choice and column_choice - the choice of the player // line 5419
} // line 5420


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5423
    u2 sampled_row_choice, sampled_column_choice; // line 5424

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5426
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5427

    // observe that the choice is feasible, and update the grid // line 5429
    if (sampled_row_choice == 0u2) { // line 5430
        observe upper[sampled_column_choice] == 0u2; // line 5431
        upper[sampled_column_choice] = current_player; // line 5432
    } else { // line 5433
        if (sampled_row_choice == 1u2) { // line 5434
            observe middle[sampled_column_choice] == 0u2; // line 5435
            middle[sampled_column_choice] = current_player; // line 5436
        } else { // line 5437
            observe lower[sampled_column_choice] == 0u2; // line 5438
            lower[sampled_column_choice] = current_player; // line 5439
        } // line 5440
    } // line 5441
    row_choice = sampled_row_choice; // line 5442
    column_choice = sampled_column_choice; // line 5443
} // line 5444

expected_utility(u2 current_player) { // line 5446
    bool coin_flip; // line 5447
    u4 utility; // line 5448

    if (final_winner == current_player) { // line 5450
        utility = 10u4; // line 5451
    } else { // line 5452
        if (final_winner == 0u2) { // line 5453
        utility = 5u4; // line 5454
        } else { // line 5455
            utility = 1u4; // line 5456
        } // line 5457
    } // line 5458

    // outcome should range from 0 to 10 // line 5460
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 5461
    observe coin_flip; // line 5462
} // line 5463

winning_condition() { // line 5465
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 5466
        final_winner = upper[0u2]; // line 5467
    } else { // line 5468
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 5469
            final_winner = middle[0u2]; // line 5470
        } else { // line 5471
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 5472
                final_winner = lower[0u2]; // line 5473
            } else { // line 5474
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 5475
                    final_winner = upper[0u2]; // line 5476
                } else { // line 5477
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 5478
                        final_winner = upper[1u2]; // line 5479
                    } else { // line 5480
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 5481
                            final_winner = upper[2u2]; // line 5482
                        } else { // line 5483
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 5484
                                final_winner = upper[0u2]; // line 5485
                            } else { // line 5486
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 5487
                                    final_winner = upper[2u2]; // line 5488
                                } else { // line 5489
                                    final_winner = 0u2; // line 5490
                                } // line 5491
                            } // line 5492
                        } // line 5493
                    } // line 5494
                } // line 5495
            } // line 5496
        } // line 5497
    } // line 5498
} // line 5499
u2[3] upper; // line 5500
u2[3] middle; // line 5501
u2[3] lower; // line 5502
u2 final_winner; // line 5503

/*   // line 5505
    0 = non assigned // line 5506
    1 = circle (player 1) // line 5507
    2 = cross (player 2) // line 5508
    Initial Condition:  // line 5509
    |   | O |   | // line 5510
    | O | X | X | // line 5511
    |   | O |   | // line 5512
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 5513
*/  // line 5514

main (){ // line 5516
    u2 row_choice, column_choice; // line 5517
    upper[0u2] = 0u2; // line 5518
	upper[1u2] = 1u2; // line 5519
	upper[2u2] = 0u2; // line 5520
    middle[0u2] = 1u2; // line 5521
	middle[1u2] = 2u2; // line 5522
	middle[2u2] = 2u2; // line 5523
    lower[0u2] = 0u2; // line 5524
	lower[1u2] = 1u2; // line 5525
	lower[2u2] = 0u2; // line 5526

    final_winner = 0u2; // line 5528
    query sampleAction(2u2, row_choice, column_choice); // line 5529

} // line 5531

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5533
    bool another_turn; // line 5534
    u2 other_player; // line 5535
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 5536
    
    // sample a choice from the priori // line 5538
    query action_priori(current_player, row_choice, column_choice); // line 5539
    
    // is there a final_winner or is the grid filled? // line 5541
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 5542
    winning_condition(); // line 5543

    // if nobody has won and there is another turn to play... // line 5545
    if (final_winner == 0u2 && another_turn) {     // line 5546
        // passing the turn // line 5547
        if (current_player == 1u2) { // line 5548
            other_player = 2u2; // line 5549
        } else { // line 5550
            other_player = 1u2; // line 5551
        } // line 5552
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 5553

    } else {} // line 5555

    // observing according to the utility of the outcome // line 5557
    expected_utility(current_player); // line 5558

    // returning row_choice and column_choice - the choice of the player // line 5560
} // line 5561


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5564
    u2 sampled_row_choice, sampled_column_choice; // line 5565

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5567
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5568

    // observe that the choice is feasible, and update the grid // line 5570
    if (sampled_row_choice == 0u2) { // line 5571
        observe upper[sampled_column_choice] == 0u2; // line 5572
        upper[sampled_column_choice] = current_player; // line 5573
    } else { // line 5574
        if (sampled_row_choice == 1u2) { // line 5575
            observe middle[sampled_column_choice] == 0u2; // line 5576
            middle[sampled_column_choice] = current_player; // line 5577
        } else { // line 5578
            observe lower[sampled_column_choice] == 0u2; // line 5579
            lower[sampled_column_choice] = current_player; // line 5580
        } // line 5581
    } // line 5582
    row_choice = sampled_row_choice; // line 5583
    column_choice = sampled_column_choice; // line 5584
} // line 5585

expected_utility(u2 current_player) { // line 5587
    bool coin_flip; // line 5588
    u4 utility; // line 5589

    if (final_winner == current_player) { // line 5591
        utility = 10u4; // line 5592
    } else { // line 5593
        if (final_winner == 0u2) { // line 5594
        utility = 5u4; // line 5595
        } else { // line 5596
            utility = 1u4; // line 5597
        } // line 5598
    } // line 5599

    // outcome should range from 0 to 10 // line 5601
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 5602
    observe coin_flip; // line 5603
} // line 5604

winning_condition() { // line 5606
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 5607
        final_winner = upper[0u2]; // line 5608
    } else { // line 5609
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 5610
            final_winner = middle[0u2]; // line 5611
        } else { // line 5612
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 5613
                final_winner = lower[0u2]; // line 5614
            } else { // line 5615
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 5616
                    final_winner = upper[0u2]; // line 5617
                } else { // line 5618
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 5619
                        final_winner = upper[1u2]; // line 5620
                    } else { // line 5621
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 5622
                            final_winner = upper[2u2]; // line 5623
                        } else { // line 5624
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 5625
                                final_winner = upper[0u2]; // line 5626
                            } else { // line 5627
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 5628
                                    final_winner = upper[2u2]; // line 5629
                                } else { // line 5630
                                    final_winner = 0u2; // line 5631
                                } // line 5632
                            } // line 5633
                        } // line 5634
                    } // line 5635
                } // line 5636
            } // line 5637
        } // line 5638
    } // line 5639
} // line 5640
u2[3] upper; // line 5641
u2[3] middle; // line 5642
u2[3] lower; // line 5643
u2 final_winner; // line 5644

/*   // line 5646
    0 = non assigned // line 5647
    1 = circle (player 1) // line 5648
    2 = cross (player 2) // line 5649
    Initial Condition:  // line 5650
    |   | O |   | // line 5651
    | O | X | X | // line 5652
    |   | O |   | // line 5653
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 5654
*/  // line 5655

main (){ // line 5657
    u2 row_choice, column_choice; // line 5658
    upper[0u2] = 0u2; // line 5659
	upper[1u2] = 1u2; // line 5660
	upper[2u2] = 0u2; // line 5661
    middle[0u2] = 1u2; // line 5662
	middle[1u2] = 2u2; // line 5663
	middle[2u2] = 2u2; // line 5664
    lower[0u2] = 0u2; // line 5665
	lower[1u2] = 1u2; // line 5666
	lower[2u2] = 0u2; // line 5667

    final_winner = 0u2; // line 5669
    query sampleAction(2u2, row_choice, column_choice); // line 5670

} // line 5672

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5674
    bool another_turn; // line 5675
    u2 other_player; // line 5676
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 5677
    
    // sample a choice from the priori // line 5679
    query action_priori(current_player, row_choice, column_choice); // line 5680
    
    // is there a final_winner or is the grid filled? // line 5682
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 5683
    winning_condition(); // line 5684

    // if nobody has won and there is another turn to play... // line 5686
    if (final_winner == 0u2 && another_turn) {     // line 5687
        // passing the turn // line 5688
        if (current_player == 1u2) { // line 5689
            other_player = 2u2; // line 5690
        } else { // line 5691
            other_player = 1u2; // line 5692
        } // line 5693
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 5694

    } else {} // line 5696

    // observing according to the utility of the outcome // line 5698
    expected_utility(current_player); // line 5699

    // returning row_choice and column_choice - the choice of the player // line 5701
} // line 5702


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5705
    u2 sampled_row_choice, sampled_column_choice; // line 5706

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5708
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5709

    // observe that the choice is feasible, and update the grid // line 5711
    if (sampled_row_choice == 0u2) { // line 5712
        observe upper[sampled_column_choice] == 0u2; // line 5713
        upper[sampled_column_choice] = current_player; // line 5714
    } else { // line 5715
        if (sampled_row_choice == 1u2) { // line 5716
            observe middle[sampled_column_choice] == 0u2; // line 5717
            middle[sampled_column_choice] = current_player; // line 5718
        } else { // line 5719
            observe lower[sampled_column_choice] == 0u2; // line 5720
            lower[sampled_column_choice] = current_player; // line 5721
        } // line 5722
    } // line 5723
    row_choice = sampled_row_choice; // line 5724
    column_choice = sampled_column_choice; // line 5725
} // line 5726

expected_utility(u2 current_player) { // line 5728
    bool coin_flip; // line 5729
    u4 utility; // line 5730

    if (final_winner == current_player) { // line 5732
        utility = 10u4; // line 5733
    } else { // line 5734
        if (final_winner == 0u2) { // line 5735
        utility = 5u4; // line 5736
        } else { // line 5737
            utility = 1u4; // line 5738
        } // line 5739
    } // line 5740

    // outcome should range from 0 to 10 // line 5742
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 5743
    observe coin_flip; // line 5744
} // line 5745

winning_condition() { // line 5747
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 5748
        final_winner = upper[0u2]; // line 5749
    } else { // line 5750
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 5751
            final_winner = middle[0u2]; // line 5752
        } else { // line 5753
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 5754
                final_winner = lower[0u2]; // line 5755
            } else { // line 5756
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 5757
                    final_winner = upper[0u2]; // line 5758
                } else { // line 5759
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 5760
                        final_winner = upper[1u2]; // line 5761
                    } else { // line 5762
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 5763
                            final_winner = upper[2u2]; // line 5764
                        } else { // line 5765
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 5766
                                final_winner = upper[0u2]; // line 5767
                            } else { // line 5768
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 5769
                                    final_winner = upper[2u2]; // line 5770
                                } else { // line 5771
                                    final_winner = 0u2; // line 5772
                                } // line 5773
                            } // line 5774
                        } // line 5775
                    } // line 5776
                } // line 5777
            } // line 5778
        } // line 5779
    } // line 5780
} // line 5781
u2[3] upper; // line 5782
u2[3] middle; // line 5783
u2[3] lower; // line 5784
u2 final_winner; // line 5785

/*   // line 5787
    0 = non assigned // line 5788
    1 = circle (player 1) // line 5789
    2 = cross (player 2) // line 5790
    Initial Condition:  // line 5791
    |   | O |   | // line 5792
    | O | X | X | // line 5793
    |   | O |   | // line 5794
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 5795
*/  // line 5796

main (){ // line 5798
    u2 row_choice, column_choice; // line 5799
    upper[0u2] = 0u2; // line 5800
	upper[1u2] = 1u2; // line 5801
	upper[2u2] = 0u2; // line 5802
    middle[0u2] = 1u2; // line 5803
	middle[1u2] = 2u2; // line 5804
	middle[2u2] = 2u2; // line 5805
    lower[0u2] = 0u2; // line 5806
	lower[1u2] = 1u2; // line 5807
	lower[2u2] = 0u2; // line 5808

    final_winner = 0u2; // line 5810
    query sampleAction(2u2, row_choice, column_choice); // line 5811

} // line 5813

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5815
    bool another_turn; // line 5816
    u2 other_player; // line 5817
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 5818
    
    // sample a choice from the priori // line 5820
    query action_priori(current_player, row_choice, column_choice); // line 5821
    
    // is there a final_winner or is the grid filled? // line 5823
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 5824
    winning_condition(); // line 5825

    // if nobody has won and there is another turn to play... // line 5827
    if (final_winner == 0u2 && another_turn) {     // line 5828
        // passing the turn // line 5829
        if (current_player == 1u2) { // line 5830
            other_player = 2u2; // line 5831
        } else { // line 5832
            other_player = 1u2; // line 5833
        } // line 5834
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 5835

    } else {} // line 5837

    // observing according to the utility of the outcome // line 5839
    expected_utility(current_player); // line 5840

    // returning row_choice and column_choice - the choice of the player // line 5842
} // line 5843


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5846
    u2 sampled_row_choice, sampled_column_choice; // line 5847

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5849
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5850

    // observe that the choice is feasible, and update the grid // line 5852
    if (sampled_row_choice == 0u2) { // line 5853
        observe upper[sampled_column_choice] == 0u2; // line 5854
        upper[sampled_column_choice] = current_player; // line 5855
    } else { // line 5856
        if (sampled_row_choice == 1u2) { // line 5857
            observe middle[sampled_column_choice] == 0u2; // line 5858
            middle[sampled_column_choice] = current_player; // line 5859
        } else { // line 5860
            observe lower[sampled_column_choice] == 0u2; // line 5861
            lower[sampled_column_choice] = current_player; // line 5862
        } // line 5863
    } // line 5864
    row_choice = sampled_row_choice; // line 5865
    column_choice = sampled_column_choice; // line 5866
} // line 5867

expected_utility(u2 current_player) { // line 5869
    bool coin_flip; // line 5870
    u4 utility; // line 5871

    if (final_winner == current_player) { // line 5873
        utility = 10u4; // line 5874
    } else { // line 5875
        if (final_winner == 0u2) { // line 5876
        utility = 5u4; // line 5877
        } else { // line 5878
            utility = 1u4; // line 5879
        } // line 5880
    } // line 5881

    // outcome should range from 0 to 10 // line 5883
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 5884
    observe coin_flip; // line 5885
} // line 5886

winning_condition() { // line 5888
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 5889
        final_winner = upper[0u2]; // line 5890
    } else { // line 5891
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 5892
            final_winner = middle[0u2]; // line 5893
        } else { // line 5894
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 5895
                final_winner = lower[0u2]; // line 5896
            } else { // line 5897
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 5898
                    final_winner = upper[0u2]; // line 5899
                } else { // line 5900
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 5901
                        final_winner = upper[1u2]; // line 5902
                    } else { // line 5903
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 5904
                            final_winner = upper[2u2]; // line 5905
                        } else { // line 5906
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 5907
                                final_winner = upper[0u2]; // line 5908
                            } else { // line 5909
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 5910
                                    final_winner = upper[2u2]; // line 5911
                                } else { // line 5912
                                    final_winner = 0u2; // line 5913
                                } // line 5914
                            } // line 5915
                        } // line 5916
                    } // line 5917
                } // line 5918
            } // line 5919
        } // line 5920
    } // line 5921
} // line 5922
u2[3] upper; // line 5923
u2[3] middle; // line 5924
u2[3] lower; // line 5925
u2 final_winner; // line 5926

/*   // line 5928
    0 = non assigned // line 5929
    1 = circle (player 1) // line 5930
    2 = cross (player 2) // line 5931
    Initial Condition:  // line 5932
    |   | O |   | // line 5933
    | O | X | X | // line 5934
    |   | O |   | // line 5935
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 5936
*/  // line 5937

main (){ // line 5939
    u2 row_choice, column_choice; // line 5940
    upper[0u2] = 0u2; // line 5941
	upper[1u2] = 1u2; // line 5942
	upper[2u2] = 0u2; // line 5943
    middle[0u2] = 1u2; // line 5944
	middle[1u2] = 2u2; // line 5945
	middle[2u2] = 2u2; // line 5946
    lower[0u2] = 0u2; // line 5947
	lower[1u2] = 1u2; // line 5948
	lower[2u2] = 0u2; // line 5949

    final_winner = 0u2; // line 5951
    query sampleAction(2u2, row_choice, column_choice); // line 5952

} // line 5954

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5956
    bool another_turn; // line 5957
    u2 other_player; // line 5958
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 5959
    
    // sample a choice from the priori // line 5961
    query action_priori(current_player, row_choice, column_choice); // line 5962
    
    // is there a final_winner or is the grid filled? // line 5964
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 5965
    winning_condition(); // line 5966

    // if nobody has won and there is another turn to play... // line 5968
    if (final_winner == 0u2 && another_turn) {     // line 5969
        // passing the turn // line 5970
        if (current_player == 1u2) { // line 5971
            other_player = 2u2; // line 5972
        } else { // line 5973
            other_player = 1u2; // line 5974
        } // line 5975
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 5976

    } else {} // line 5978

    // observing according to the utility of the outcome // line 5980
    expected_utility(current_player); // line 5981

    // returning row_choice and column_choice - the choice of the player // line 5983
} // line 5984


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 5987
    u2 sampled_row_choice, sampled_column_choice; // line 5988

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5990
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 5991

    // observe that the choice is feasible, and update the grid // line 5993
    if (sampled_row_choice == 0u2) { // line 5994
        observe upper[sampled_column_choice] == 0u2; // line 5995
        upper[sampled_column_choice] = current_player; // line 5996
    } else { // line 5997
        if (sampled_row_choice == 1u2) { // line 5998
            observe middle[sampled_column_choice] == 0u2; // line 5999
            middle[sampled_column_choice] = current_player; // line 6000
        } else { // line 6001
            observe lower[sampled_column_choice] == 0u2; // line 6002
            lower[sampled_column_choice] = current_player; // line 6003
        } // line 6004
    } // line 6005
    row_choice = sampled_row_choice; // line 6006
    column_choice = sampled_column_choice; // line 6007
} // line 6008

expected_utility(u2 current_player) { // line 6010
    bool coin_flip; // line 6011
    u4 utility; // line 6012

    if (final_winner == current_player) { // line 6014
        utility = 10u4; // line 6015
    } else { // line 6016
        if (final_winner == 0u2) { // line 6017
        utility = 5u4; // line 6018
        } else { // line 6019
            utility = 1u4; // line 6020
        } // line 6021
    } // line 6022

    // outcome should range from 0 to 10 // line 6024
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 6025
    observe coin_flip; // line 6026
} // line 6027

winning_condition() { // line 6029
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 6030
        final_winner = upper[0u2]; // line 6031
    } else { // line 6032
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 6033
            final_winner = middle[0u2]; // line 6034
        } else { // line 6035
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 6036
                final_winner = lower[0u2]; // line 6037
            } else { // line 6038
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 6039
                    final_winner = upper[0u2]; // line 6040
                } else { // line 6041
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 6042
                        final_winner = upper[1u2]; // line 6043
                    } else { // line 6044
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 6045
                            final_winner = upper[2u2]; // line 6046
                        } else { // line 6047
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 6048
                                final_winner = upper[0u2]; // line 6049
                            } else { // line 6050
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 6051
                                    final_winner = upper[2u2]; // line 6052
                                } else { // line 6053
                                    final_winner = 0u2; // line 6054
                                } // line 6055
                            } // line 6056
                        } // line 6057
                    } // line 6058
                } // line 6059
            } // line 6060
        } // line 6061
    } // line 6062
} // line 6063
u2[3] upper; // line 6064
u2[3] middle; // line 6065
u2[3] lower; // line 6066
u2 final_winner; // line 6067

/*   // line 6069
    0 = non assigned // line 6070
    1 = circle (player 1) // line 6071
    2 = cross (player 2) // line 6072
    Initial Condition:  // line 6073
    |   | O |   | // line 6074
    | O | X | X | // line 6075
    |   | O |   | // line 6076
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 6077
*/  // line 6078

main (){ // line 6080
    u2 row_choice, column_choice; // line 6081
    upper[0u2] = 0u2; // line 6082
	upper[1u2] = 1u2; // line 6083
	upper[2u2] = 0u2; // line 6084
    middle[0u2] = 1u2; // line 6085
	middle[1u2] = 2u2; // line 6086
	middle[2u2] = 2u2; // line 6087
    lower[0u2] = 0u2; // line 6088
	lower[1u2] = 1u2; // line 6089
	lower[2u2] = 0u2; // line 6090

    final_winner = 0u2; // line 6092
    query sampleAction(2u2, row_choice, column_choice); // line 6093

} // line 6095

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6097
    bool another_turn; // line 6098
    u2 other_player; // line 6099
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 6100
    
    // sample a choice from the priori // line 6102
    query action_priori(current_player, row_choice, column_choice); // line 6103
    
    // is there a final_winner or is the grid filled? // line 6105
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 6106
    winning_condition(); // line 6107

    // if nobody has won and there is another turn to play... // line 6109
    if (final_winner == 0u2 && another_turn) {     // line 6110
        // passing the turn // line 6111
        if (current_player == 1u2) { // line 6112
            other_player = 2u2; // line 6113
        } else { // line 6114
            other_player = 1u2; // line 6115
        } // line 6116
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 6117

    } else {} // line 6119

    // observing according to the utility of the outcome // line 6121
    expected_utility(current_player); // line 6122

    // returning row_choice and column_choice - the choice of the player // line 6124
} // line 6125


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6128
    u2 sampled_row_choice, sampled_column_choice; // line 6129

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6131
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6132

    // observe that the choice is feasible, and update the grid // line 6134
    if (sampled_row_choice == 0u2) { // line 6135
        observe upper[sampled_column_choice] == 0u2; // line 6136
        upper[sampled_column_choice] = current_player; // line 6137
    } else { // line 6138
        if (sampled_row_choice == 1u2) { // line 6139
            observe middle[sampled_column_choice] == 0u2; // line 6140
            middle[sampled_column_choice] = current_player; // line 6141
        } else { // line 6142
            observe lower[sampled_column_choice] == 0u2; // line 6143
            lower[sampled_column_choice] = current_player; // line 6144
        } // line 6145
    } // line 6146
    row_choice = sampled_row_choice; // line 6147
    column_choice = sampled_column_choice; // line 6148
} // line 6149

expected_utility(u2 current_player) { // line 6151
    bool coin_flip; // line 6152
    u4 utility; // line 6153

    if (final_winner == current_player) { // line 6155
        utility = 10u4; // line 6156
    } else { // line 6157
        if (final_winner == 0u2) { // line 6158
        utility = 5u4; // line 6159
        } else { // line 6160
            utility = 1u4; // line 6161
        } // line 6162
    } // line 6163

    // outcome should range from 0 to 10 // line 6165
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 6166
    observe coin_flip; // line 6167
} // line 6168

winning_condition() { // line 6170
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 6171
        final_winner = upper[0u2]; // line 6172
    } else { // line 6173
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 6174
            final_winner = middle[0u2]; // line 6175
        } else { // line 6176
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 6177
                final_winner = lower[0u2]; // line 6178
            } else { // line 6179
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 6180
                    final_winner = upper[0u2]; // line 6181
                } else { // line 6182
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 6183
                        final_winner = upper[1u2]; // line 6184
                    } else { // line 6185
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 6186
                            final_winner = upper[2u2]; // line 6187
                        } else { // line 6188
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 6189
                                final_winner = upper[0u2]; // line 6190
                            } else { // line 6191
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 6192
                                    final_winner = upper[2u2]; // line 6193
                                } else { // line 6194
                                    final_winner = 0u2; // line 6195
                                } // line 6196
                            } // line 6197
                        } // line 6198
                    } // line 6199
                } // line 6200
            } // line 6201
        } // line 6202
    } // line 6203
} // line 6204
u2[3] upper; // line 6205
u2[3] middle; // line 6206
u2[3] lower; // line 6207
u2 final_winner; // line 6208

/*   // line 6210
    0 = non assigned // line 6211
    1 = circle (player 1) // line 6212
    2 = cross (player 2) // line 6213
    Initial Condition:  // line 6214
    |   | O |   | // line 6215
    | O | X | X | // line 6216
    |   | O |   | // line 6217
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 6218
*/  // line 6219

main (){ // line 6221
    u2 row_choice, column_choice; // line 6222
    upper[0u2] = 0u2; // line 6223
	upper[1u2] = 1u2; // line 6224
	upper[2u2] = 0u2; // line 6225
    middle[0u2] = 1u2; // line 6226
	middle[1u2] = 2u2; // line 6227
	middle[2u2] = 2u2; // line 6228
    lower[0u2] = 0u2; // line 6229
	lower[1u2] = 1u2; // line 6230
	lower[2u2] = 0u2; // line 6231

    final_winner = 0u2; // line 6233
    query sampleAction(2u2, row_choice, column_choice); // line 6234

} // line 6236

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6238
    bool another_turn; // line 6239
    u2 other_player; // line 6240
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 6241
    
    // sample a choice from the priori // line 6243
    query action_priori(current_player, row_choice, column_choice); // line 6244
    
    // is there a final_winner or is the grid filled? // line 6246
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 6247
    winning_condition(); // line 6248

    // if nobody has won and there is another turn to play... // line 6250
    if (final_winner == 0u2 && another_turn) {     // line 6251
        // passing the turn // line 6252
        if (current_player == 1u2) { // line 6253
            other_player = 2u2; // line 6254
        } else { // line 6255
            other_player = 1u2; // line 6256
        } // line 6257
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 6258

    } else {} // line 6260

    // observing according to the utility of the outcome // line 6262
    expected_utility(current_player); // line 6263

    // returning row_choice and column_choice - the choice of the player // line 6265
} // line 6266


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6269
    u2 sampled_row_choice, sampled_column_choice; // line 6270

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6272
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6273

    // observe that the choice is feasible, and update the grid // line 6275
    if (sampled_row_choice == 0u2) { // line 6276
        observe upper[sampled_column_choice] == 0u2; // line 6277
        upper[sampled_column_choice] = current_player; // line 6278
    } else { // line 6279
        if (sampled_row_choice == 1u2) { // line 6280
            observe middle[sampled_column_choice] == 0u2; // line 6281
            middle[sampled_column_choice] = current_player; // line 6282
        } else { // line 6283
            observe lower[sampled_column_choice] == 0u2; // line 6284
            lower[sampled_column_choice] = current_player; // line 6285
        } // line 6286
    } // line 6287
    row_choice = sampled_row_choice; // line 6288
    column_choice = sampled_column_choice; // line 6289
} // line 6290

expected_utility(u2 current_player) { // line 6292
    bool coin_flip; // line 6293
    u4 utility; // line 6294

    if (final_winner == current_player) { // line 6296
        utility = 10u4; // line 6297
    } else { // line 6298
        if (final_winner == 0u2) { // line 6299
        utility = 5u4; // line 6300
        } else { // line 6301
            utility = 1u4; // line 6302
        } // line 6303
    } // line 6304

    // outcome should range from 0 to 10 // line 6306
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 6307
    observe coin_flip; // line 6308
} // line 6309

winning_condition() { // line 6311
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 6312
        final_winner = upper[0u2]; // line 6313
    } else { // line 6314
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 6315
            final_winner = middle[0u2]; // line 6316
        } else { // line 6317
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 6318
                final_winner = lower[0u2]; // line 6319
            } else { // line 6320
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 6321
                    final_winner = upper[0u2]; // line 6322
                } else { // line 6323
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 6324
                        final_winner = upper[1u2]; // line 6325
                    } else { // line 6326
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 6327
                            final_winner = upper[2u2]; // line 6328
                        } else { // line 6329
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 6330
                                final_winner = upper[0u2]; // line 6331
                            } else { // line 6332
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 6333
                                    final_winner = upper[2u2]; // line 6334
                                } else { // line 6335
                                    final_winner = 0u2; // line 6336
                                } // line 6337
                            } // line 6338
                        } // line 6339
                    } // line 6340
                } // line 6341
            } // line 6342
        } // line 6343
    } // line 6344
} // line 6345
u2[3] upper; // line 6346
u2[3] middle; // line 6347
u2[3] lower; // line 6348
u2 final_winner; // line 6349

/*   // line 6351
    0 = non assigned // line 6352
    1 = circle (player 1) // line 6353
    2 = cross (player 2) // line 6354
    Initial Condition:  // line 6355
    |   | O |   | // line 6356
    | O | X | X | // line 6357
    |   | O |   | // line 6358
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 6359
*/  // line 6360

main (){ // line 6362
    u2 row_choice, column_choice; // line 6363
    upper[0u2] = 0u2; // line 6364
	upper[1u2] = 1u2; // line 6365
	upper[2u2] = 0u2; // line 6366
    middle[0u2] = 1u2; // line 6367
	middle[1u2] = 2u2; // line 6368
	middle[2u2] = 2u2; // line 6369
    lower[0u2] = 0u2; // line 6370
	lower[1u2] = 1u2; // line 6371
	lower[2u2] = 0u2; // line 6372

    final_winner = 0u2; // line 6374
    query sampleAction(2u2, row_choice, column_choice); // line 6375

} // line 6377

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6379
    bool another_turn; // line 6380
    u2 other_player; // line 6381
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 6382
    
    // sample a choice from the priori // line 6384
    query action_priori(current_player, row_choice, column_choice); // line 6385
    
    // is there a final_winner or is the grid filled? // line 6387
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 6388
    winning_condition(); // line 6389

    // if nobody has won and there is another turn to play... // line 6391
    if (final_winner == 0u2 && another_turn) {     // line 6392
        // passing the turn // line 6393
        if (current_player == 1u2) { // line 6394
            other_player = 2u2; // line 6395
        } else { // line 6396
            other_player = 1u2; // line 6397
        } // line 6398
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 6399

    } else {} // line 6401

    // observing according to the utility of the outcome // line 6403
    expected_utility(current_player); // line 6404

    // returning row_choice and column_choice - the choice of the player // line 6406
} // line 6407


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6410
    u2 sampled_row_choice, sampled_column_choice; // line 6411

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6413
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6414

    // observe that the choice is feasible, and update the grid // line 6416
    if (sampled_row_choice == 0u2) { // line 6417
        observe upper[sampled_column_choice] == 0u2; // line 6418
        upper[sampled_column_choice] = current_player; // line 6419
    } else { // line 6420
        if (sampled_row_choice == 1u2) { // line 6421
            observe middle[sampled_column_choice] == 0u2; // line 6422
            middle[sampled_column_choice] = current_player; // line 6423
        } else { // line 6424
            observe lower[sampled_column_choice] == 0u2; // line 6425
            lower[sampled_column_choice] = current_player; // line 6426
        } // line 6427
    } // line 6428
    row_choice = sampled_row_choice; // line 6429
    column_choice = sampled_column_choice; // line 6430
} // line 6431

expected_utility(u2 current_player) { // line 6433
    bool coin_flip; // line 6434
    u4 utility; // line 6435

    if (final_winner == current_player) { // line 6437
        utility = 10u4; // line 6438
    } else { // line 6439
        if (final_winner == 0u2) { // line 6440
        utility = 5u4; // line 6441
        } else { // line 6442
            utility = 1u4; // line 6443
        } // line 6444
    } // line 6445

    // outcome should range from 0 to 10 // line 6447
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 6448
    observe coin_flip; // line 6449
} // line 6450

winning_condition() { // line 6452
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 6453
        final_winner = upper[0u2]; // line 6454
    } else { // line 6455
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 6456
            final_winner = middle[0u2]; // line 6457
        } else { // line 6458
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 6459
                final_winner = lower[0u2]; // line 6460
            } else { // line 6461
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 6462
                    final_winner = upper[0u2]; // line 6463
                } else { // line 6464
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 6465
                        final_winner = upper[1u2]; // line 6466
                    } else { // line 6467
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 6468
                            final_winner = upper[2u2]; // line 6469
                        } else { // line 6470
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 6471
                                final_winner = upper[0u2]; // line 6472
                            } else { // line 6473
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 6474
                                    final_winner = upper[2u2]; // line 6475
                                } else { // line 6476
                                    final_winner = 0u2; // line 6477
                                } // line 6478
                            } // line 6479
                        } // line 6480
                    } // line 6481
                } // line 6482
            } // line 6483
        } // line 6484
    } // line 6485
} // line 6486
u2[3] upper; // line 6487
u2[3] middle; // line 6488
u2[3] lower; // line 6489
u2 final_winner; // line 6490

/*   // line 6492
    0 = non assigned // line 6493
    1 = circle (player 1) // line 6494
    2 = cross (player 2) // line 6495
    Initial Condition:  // line 6496
    |   | O |   | // line 6497
    | O | X | X | // line 6498
    |   | O |   | // line 6499
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 6500
*/  // line 6501

main (){ // line 6503
    u2 row_choice, column_choice; // line 6504
    upper[0u2] = 0u2; // line 6505
	upper[1u2] = 1u2; // line 6506
	upper[2u2] = 0u2; // line 6507
    middle[0u2] = 1u2; // line 6508
	middle[1u2] = 2u2; // line 6509
	middle[2u2] = 2u2; // line 6510
    lower[0u2] = 0u2; // line 6511
	lower[1u2] = 1u2; // line 6512
	lower[2u2] = 0u2; // line 6513

    final_winner = 0u2; // line 6515
    query sampleAction(2u2, row_choice, column_choice); // line 6516

} // line 6518

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6520
    bool another_turn; // line 6521
    u2 other_player; // line 6522
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 6523
    
    // sample a choice from the priori // line 6525
    query action_priori(current_player, row_choice, column_choice); // line 6526
    
    // is there a final_winner or is the grid filled? // line 6528
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 6529
    winning_condition(); // line 6530

    // if nobody has won and there is another turn to play... // line 6532
    if (final_winner == 0u2 && another_turn) {     // line 6533
        // passing the turn // line 6534
        if (current_player == 1u2) { // line 6535
            other_player = 2u2; // line 6536
        } else { // line 6537
            other_player = 1u2; // line 6538
        } // line 6539
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 6540

    } else {} // line 6542

    // observing according to the utility of the outcome // line 6544
    expected_utility(current_player); // line 6545

    // returning row_choice and column_choice - the choice of the player // line 6547
} // line 6548


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6551
    u2 sampled_row_choice, sampled_column_choice; // line 6552

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6554
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6555

    // observe that the choice is feasible, and update the grid // line 6557
    if (sampled_row_choice == 0u2) { // line 6558
        observe upper[sampled_column_choice] == 0u2; // line 6559
        upper[sampled_column_choice] = current_player; // line 6560
    } else { // line 6561
        if (sampled_row_choice == 1u2) { // line 6562
            observe middle[sampled_column_choice] == 0u2; // line 6563
            middle[sampled_column_choice] = current_player; // line 6564
        } else { // line 6565
            observe lower[sampled_column_choice] == 0u2; // line 6566
            lower[sampled_column_choice] = current_player; // line 6567
        } // line 6568
    } // line 6569
    row_choice = sampled_row_choice; // line 6570
    column_choice = sampled_column_choice; // line 6571
} // line 6572

expected_utility(u2 current_player) { // line 6574
    bool coin_flip; // line 6575
    u4 utility; // line 6576

    if (final_winner == current_player) { // line 6578
        utility = 10u4; // line 6579
    } else { // line 6580
        if (final_winner == 0u2) { // line 6581
        utility = 5u4; // line 6582
        } else { // line 6583
            utility = 1u4; // line 6584
        } // line 6585
    } // line 6586

    // outcome should range from 0 to 10 // line 6588
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 6589
    observe coin_flip; // line 6590
} // line 6591

winning_condition() { // line 6593
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 6594
        final_winner = upper[0u2]; // line 6595
    } else { // line 6596
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 6597
            final_winner = middle[0u2]; // line 6598
        } else { // line 6599
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 6600
                final_winner = lower[0u2]; // line 6601
            } else { // line 6602
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 6603
                    final_winner = upper[0u2]; // line 6604
                } else { // line 6605
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 6606
                        final_winner = upper[1u2]; // line 6607
                    } else { // line 6608
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 6609
                            final_winner = upper[2u2]; // line 6610
                        } else { // line 6611
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 6612
                                final_winner = upper[0u2]; // line 6613
                            } else { // line 6614
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 6615
                                    final_winner = upper[2u2]; // line 6616
                                } else { // line 6617
                                    final_winner = 0u2; // line 6618
                                } // line 6619
                            } // line 6620
                        } // line 6621
                    } // line 6622
                } // line 6623
            } // line 6624
        } // line 6625
    } // line 6626
} // line 6627
u2[3] upper; // line 6628
u2[3] middle; // line 6629
u2[3] lower; // line 6630
u2 final_winner; // line 6631

/*   // line 6633
    0 = non assigned // line 6634
    1 = circle (player 1) // line 6635
    2 = cross (player 2) // line 6636
    Initial Condition:  // line 6637
    |   | O |   | // line 6638
    | O | X | X | // line 6639
    |   | O |   | // line 6640
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 6641
*/  // line 6642

main (){ // line 6644
    u2 row_choice, column_choice; // line 6645
    upper[0u2] = 0u2; // line 6646
	upper[1u2] = 1u2; // line 6647
	upper[2u2] = 0u2; // line 6648
    middle[0u2] = 1u2; // line 6649
	middle[1u2] = 2u2; // line 6650
	middle[2u2] = 2u2; // line 6651
    lower[0u2] = 0u2; // line 6652
	lower[1u2] = 1u2; // line 6653
	lower[2u2] = 0u2; // line 6654

    final_winner = 0u2; // line 6656
    query sampleAction(2u2, row_choice, column_choice); // line 6657

} // line 6659

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6661
    bool another_turn; // line 6662
    u2 other_player; // line 6663
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 6664
    
    // sample a choice from the priori // line 6666
    query action_priori(current_player, row_choice, column_choice); // line 6667
    
    // is there a final_winner or is the grid filled? // line 6669
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 6670
    winning_condition(); // line 6671

    // if nobody has won and there is another turn to play... // line 6673
    if (final_winner == 0u2 && another_turn) {     // line 6674
        // passing the turn // line 6675
        if (current_player == 1u2) { // line 6676
            other_player = 2u2; // line 6677
        } else { // line 6678
            other_player = 1u2; // line 6679
        } // line 6680
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 6681

    } else {} // line 6683

    // observing according to the utility of the outcome // line 6685
    expected_utility(current_player); // line 6686

    // returning row_choice and column_choice - the choice of the player // line 6688
} // line 6689


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6692
    u2 sampled_row_choice, sampled_column_choice; // line 6693

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6695
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6696

    // observe that the choice is feasible, and update the grid // line 6698
    if (sampled_row_choice == 0u2) { // line 6699
        observe upper[sampled_column_choice] == 0u2; // line 6700
        upper[sampled_column_choice] = current_player; // line 6701
    } else { // line 6702
        if (sampled_row_choice == 1u2) { // line 6703
            observe middle[sampled_column_choice] == 0u2; // line 6704
            middle[sampled_column_choice] = current_player; // line 6705
        } else { // line 6706
            observe lower[sampled_column_choice] == 0u2; // line 6707
            lower[sampled_column_choice] = current_player; // line 6708
        } // line 6709
    } // line 6710
    row_choice = sampled_row_choice; // line 6711
    column_choice = sampled_column_choice; // line 6712
} // line 6713

expected_utility(u2 current_player) { // line 6715
    bool coin_flip; // line 6716
    u4 utility; // line 6717

    if (final_winner == current_player) { // line 6719
        utility = 10u4; // line 6720
    } else { // line 6721
        if (final_winner == 0u2) { // line 6722
        utility = 5u4; // line 6723
        } else { // line 6724
            utility = 1u4; // line 6725
        } // line 6726
    } // line 6727

    // outcome should range from 0 to 10 // line 6729
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 6730
    observe coin_flip; // line 6731
} // line 6732

winning_condition() { // line 6734
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 6735
        final_winner = upper[0u2]; // line 6736
    } else { // line 6737
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 6738
            final_winner = middle[0u2]; // line 6739
        } else { // line 6740
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 6741
                final_winner = lower[0u2]; // line 6742
            } else { // line 6743
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 6744
                    final_winner = upper[0u2]; // line 6745
                } else { // line 6746
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 6747
                        final_winner = upper[1u2]; // line 6748
                    } else { // line 6749
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 6750
                            final_winner = upper[2u2]; // line 6751
                        } else { // line 6752
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 6753
                                final_winner = upper[0u2]; // line 6754
                            } else { // line 6755
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 6756
                                    final_winner = upper[2u2]; // line 6757
                                } else { // line 6758
                                    final_winner = 0u2; // line 6759
                                } // line 6760
                            } // line 6761
                        } // line 6762
                    } // line 6763
                } // line 6764
            } // line 6765
        } // line 6766
    } // line 6767
} // line 6768
u2[3] upper; // line 6769
u2[3] middle; // line 6770
u2[3] lower; // line 6771
u2 final_winner; // line 6772

/*   // line 6774
    0 = non assigned // line 6775
    1 = circle (player 1) // line 6776
    2 = cross (player 2) // line 6777
    Initial Condition:  // line 6778
    |   | O |   | // line 6779
    | O | X | X | // line 6780
    |   | O |   | // line 6781
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 6782
*/  // line 6783

main (){ // line 6785
    u2 row_choice, column_choice; // line 6786
    upper[0u2] = 0u2; // line 6787
	upper[1u2] = 1u2; // line 6788
	upper[2u2] = 0u2; // line 6789
    middle[0u2] = 1u2; // line 6790
	middle[1u2] = 2u2; // line 6791
	middle[2u2] = 2u2; // line 6792
    lower[0u2] = 0u2; // line 6793
	lower[1u2] = 1u2; // line 6794
	lower[2u2] = 0u2; // line 6795

    final_winner = 0u2; // line 6797
    query sampleAction(2u2, row_choice, column_choice); // line 6798

} // line 6800

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6802
    bool another_turn; // line 6803
    u2 other_player; // line 6804
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 6805
    
    // sample a choice from the priori // line 6807
    query action_priori(current_player, row_choice, column_choice); // line 6808
    
    // is there a final_winner or is the grid filled? // line 6810
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 6811
    winning_condition(); // line 6812

    // if nobody has won and there is another turn to play... // line 6814
    if (final_winner == 0u2 && another_turn) {     // line 6815
        // passing the turn // line 6816
        if (current_player == 1u2) { // line 6817
            other_player = 2u2; // line 6818
        } else { // line 6819
            other_player = 1u2; // line 6820
        } // line 6821
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 6822

    } else {} // line 6824

    // observing according to the utility of the outcome // line 6826
    expected_utility(current_player); // line 6827

    // returning row_choice and column_choice - the choice of the player // line 6829
} // line 6830


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6833
    u2 sampled_row_choice, sampled_column_choice; // line 6834

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6836
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6837

    // observe that the choice is feasible, and update the grid // line 6839
    if (sampled_row_choice == 0u2) { // line 6840
        observe upper[sampled_column_choice] == 0u2; // line 6841
        upper[sampled_column_choice] = current_player; // line 6842
    } else { // line 6843
        if (sampled_row_choice == 1u2) { // line 6844
            observe middle[sampled_column_choice] == 0u2; // line 6845
            middle[sampled_column_choice] = current_player; // line 6846
        } else { // line 6847
            observe lower[sampled_column_choice] == 0u2; // line 6848
            lower[sampled_column_choice] = current_player; // line 6849
        } // line 6850
    } // line 6851
    row_choice = sampled_row_choice; // line 6852
    column_choice = sampled_column_choice; // line 6853
} // line 6854

expected_utility(u2 current_player) { // line 6856
    bool coin_flip; // line 6857
    u4 utility; // line 6858

    if (final_winner == current_player) { // line 6860
        utility = 10u4; // line 6861
    } else { // line 6862
        if (final_winner == 0u2) { // line 6863
        utility = 5u4; // line 6864
        } else { // line 6865
            utility = 1u4; // line 6866
        } // line 6867
    } // line 6868

    // outcome should range from 0 to 10 // line 6870
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 6871
    observe coin_flip; // line 6872
} // line 6873

winning_condition() { // line 6875
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 6876
        final_winner = upper[0u2]; // line 6877
    } else { // line 6878
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 6879
            final_winner = middle[0u2]; // line 6880
        } else { // line 6881
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 6882
                final_winner = lower[0u2]; // line 6883
            } else { // line 6884
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 6885
                    final_winner = upper[0u2]; // line 6886
                } else { // line 6887
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 6888
                        final_winner = upper[1u2]; // line 6889
                    } else { // line 6890
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 6891
                            final_winner = upper[2u2]; // line 6892
                        } else { // line 6893
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 6894
                                final_winner = upper[0u2]; // line 6895
                            } else { // line 6896
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 6897
                                    final_winner = upper[2u2]; // line 6898
                                } else { // line 6899
                                    final_winner = 0u2; // line 6900
                                } // line 6901
                            } // line 6902
                        } // line 6903
                    } // line 6904
                } // line 6905
            } // line 6906
        } // line 6907
    } // line 6908
} // line 6909
u2[3] upper; // line 6910
u2[3] middle; // line 6911
u2[3] lower; // line 6912
u2 final_winner; // line 6913

/*   // line 6915
    0 = non assigned // line 6916
    1 = circle (player 1) // line 6917
    2 = cross (player 2) // line 6918
    Initial Condition:  // line 6919
    |   | O |   | // line 6920
    | O | X | X | // line 6921
    |   | O |   | // line 6922
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 6923
*/  // line 6924

main (){ // line 6926
    u2 row_choice, column_choice; // line 6927
    upper[0u2] = 0u2; // line 6928
	upper[1u2] = 1u2; // line 6929
	upper[2u2] = 0u2; // line 6930
    middle[0u2] = 1u2; // line 6931
	middle[1u2] = 2u2; // line 6932
	middle[2u2] = 2u2; // line 6933
    lower[0u2] = 0u2; // line 6934
	lower[1u2] = 1u2; // line 6935
	lower[2u2] = 0u2; // line 6936

    final_winner = 0u2; // line 6938
    query sampleAction(2u2, row_choice, column_choice); // line 6939

} // line 6941

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6943
    bool another_turn; // line 6944
    u2 other_player; // line 6945
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 6946
    
    // sample a choice from the priori // line 6948
    query action_priori(current_player, row_choice, column_choice); // line 6949
    
    // is there a final_winner or is the grid filled? // line 6951
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 6952
    winning_condition(); // line 6953

    // if nobody has won and there is another turn to play... // line 6955
    if (final_winner == 0u2 && another_turn) {     // line 6956
        // passing the turn // line 6957
        if (current_player == 1u2) { // line 6958
            other_player = 2u2; // line 6959
        } else { // line 6960
            other_player = 1u2; // line 6961
        } // line 6962
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 6963

    } else {} // line 6965

    // observing according to the utility of the outcome // line 6967
    expected_utility(current_player); // line 6968

    // returning row_choice and column_choice - the choice of the player // line 6970
} // line 6971


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 6974
    u2 sampled_row_choice, sampled_column_choice; // line 6975

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6977
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 6978

    // observe that the choice is feasible, and update the grid // line 6980
    if (sampled_row_choice == 0u2) { // line 6981
        observe upper[sampled_column_choice] == 0u2; // line 6982
        upper[sampled_column_choice] = current_player; // line 6983
    } else { // line 6984
        if (sampled_row_choice == 1u2) { // line 6985
            observe middle[sampled_column_choice] == 0u2; // line 6986
            middle[sampled_column_choice] = current_player; // line 6987
        } else { // line 6988
            observe lower[sampled_column_choice] == 0u2; // line 6989
            lower[sampled_column_choice] = current_player; // line 6990
        } // line 6991
    } // line 6992
    row_choice = sampled_row_choice; // line 6993
    column_choice = sampled_column_choice; // line 6994
} // line 6995

expected_utility(u2 current_player) { // line 6997
    bool coin_flip; // line 6998
    u4 utility; // line 6999

    if (final_winner == current_player) { // line 7001
        utility = 10u4; // line 7002
    } else { // line 7003
        if (final_winner == 0u2) { // line 7004
        utility = 5u4; // line 7005
        } else { // line 7006
            utility = 1u4; // line 7007
        } // line 7008
    } // line 7009

    // outcome should range from 0 to 10 // line 7011
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7012
    observe coin_flip; // line 7013
} // line 7014

winning_condition() { // line 7016
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 7017
        final_winner = upper[0u2]; // line 7018
    } else { // line 7019
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 7020
            final_winner = middle[0u2]; // line 7021
        } else { // line 7022
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 7023
                final_winner = lower[0u2]; // line 7024
            } else { // line 7025
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 7026
                    final_winner = upper[0u2]; // line 7027
                } else { // line 7028
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 7029
                        final_winner = upper[1u2]; // line 7030
                    } else { // line 7031
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 7032
                            final_winner = upper[2u2]; // line 7033
                        } else { // line 7034
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 7035
                                final_winner = upper[0u2]; // line 7036
                            } else { // line 7037
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 7038
                                    final_winner = upper[2u2]; // line 7039
                                } else { // line 7040
                                    final_winner = 0u2; // line 7041
                                } // line 7042
                            } // line 7043
                        } // line 7044
                    } // line 7045
                } // line 7046
            } // line 7047
        } // line 7048
    } // line 7049
} // line 7050
u2[3] upper; // line 7051
u2[3] middle; // line 7052
u2[3] lower; // line 7053
u2 final_winner; // line 7054

/*   // line 7056
    0 = non assigned // line 7057
    1 = circle (player 1) // line 7058
    2 = cross (player 2) // line 7059
    Initial Condition:  // line 7060
    |   | O |   | // line 7061
    | O | X | X | // line 7062
    |   | O |   | // line 7063
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 7064
*/  // line 7065

main (){ // line 7067
    u2 row_choice, column_choice; // line 7068
    upper[0u2] = 0u2; // line 7069
	upper[1u2] = 1u2; // line 7070
	upper[2u2] = 0u2; // line 7071
    middle[0u2] = 1u2; // line 7072
	middle[1u2] = 2u2; // line 7073
	middle[2u2] = 2u2; // line 7074
    lower[0u2] = 0u2; // line 7075
	lower[1u2] = 1u2; // line 7076
	lower[2u2] = 0u2; // line 7077

    final_winner = 0u2; // line 7079
    query sampleAction(2u2, row_choice, column_choice); // line 7080

} // line 7082

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7084
    bool another_turn; // line 7085
    u2 other_player; // line 7086
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 7087
    
    // sample a choice from the priori // line 7089
    query action_priori(current_player, row_choice, column_choice); // line 7090
    
    // is there a final_winner or is the grid filled? // line 7092
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 7093
    winning_condition(); // line 7094

    // if nobody has won and there is another turn to play... // line 7096
    if (final_winner == 0u2 && another_turn) {     // line 7097
        // passing the turn // line 7098
        if (current_player == 1u2) { // line 7099
            other_player = 2u2; // line 7100
        } else { // line 7101
            other_player = 1u2; // line 7102
        } // line 7103
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 7104

    } else {} // line 7106

    // observing according to the utility of the outcome // line 7108
    expected_utility(current_player); // line 7109

    // returning row_choice and column_choice - the choice of the player // line 7111
} // line 7112


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7115
    u2 sampled_row_choice, sampled_column_choice; // line 7116

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7118
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7119

    // observe that the choice is feasible, and update the grid // line 7121
    if (sampled_row_choice == 0u2) { // line 7122
        observe upper[sampled_column_choice] == 0u2; // line 7123
        upper[sampled_column_choice] = current_player; // line 7124
    } else { // line 7125
        if (sampled_row_choice == 1u2) { // line 7126
            observe middle[sampled_column_choice] == 0u2; // line 7127
            middle[sampled_column_choice] = current_player; // line 7128
        } else { // line 7129
            observe lower[sampled_column_choice] == 0u2; // line 7130
            lower[sampled_column_choice] = current_player; // line 7131
        } // line 7132
    } // line 7133
    row_choice = sampled_row_choice; // line 7134
    column_choice = sampled_column_choice; // line 7135
} // line 7136

expected_utility(u2 current_player) { // line 7138
    bool coin_flip; // line 7139
    u4 utility; // line 7140

    if (final_winner == current_player) { // line 7142
        utility = 10u4; // line 7143
    } else { // line 7144
        if (final_winner == 0u2) { // line 7145
        utility = 5u4; // line 7146
        } else { // line 7147
            utility = 1u4; // line 7148
        } // line 7149
    } // line 7150

    // outcome should range from 0 to 10 // line 7152
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7153
    observe coin_flip; // line 7154
} // line 7155

winning_condition() { // line 7157
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 7158
        final_winner = upper[0u2]; // line 7159
    } else { // line 7160
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 7161
            final_winner = middle[0u2]; // line 7162
        } else { // line 7163
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 7164
                final_winner = lower[0u2]; // line 7165
            } else { // line 7166
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 7167
                    final_winner = upper[0u2]; // line 7168
                } else { // line 7169
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 7170
                        final_winner = upper[1u2]; // line 7171
                    } else { // line 7172
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 7173
                            final_winner = upper[2u2]; // line 7174
                        } else { // line 7175
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 7176
                                final_winner = upper[0u2]; // line 7177
                            } else { // line 7178
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 7179
                                    final_winner = upper[2u2]; // line 7180
                                } else { // line 7181
                                    final_winner = 0u2; // line 7182
                                } // line 7183
                            } // line 7184
                        } // line 7185
                    } // line 7186
                } // line 7187
            } // line 7188
        } // line 7189
    } // line 7190
} // line 7191
u2[3] upper; // line 7192
u2[3] middle; // line 7193
u2[3] lower; // line 7194
u2 final_winner; // line 7195

/*   // line 7197
    0 = non assigned // line 7198
    1 = circle (player 1) // line 7199
    2 = cross (player 2) // line 7200
    Initial Condition:  // line 7201
    |   | O |   | // line 7202
    | O | X | X | // line 7203
    |   | O |   | // line 7204
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 7205
*/  // line 7206

main (){ // line 7208
    u2 row_choice, column_choice; // line 7209
    upper[0u2] = 0u2; // line 7210
	upper[1u2] = 1u2; // line 7211
	upper[2u2] = 0u2; // line 7212
    middle[0u2] = 1u2; // line 7213
	middle[1u2] = 2u2; // line 7214
	middle[2u2] = 2u2; // line 7215
    lower[0u2] = 0u2; // line 7216
	lower[1u2] = 1u2; // line 7217
	lower[2u2] = 0u2; // line 7218

    final_winner = 0u2; // line 7220
    query sampleAction(2u2, row_choice, column_choice); // line 7221

} // line 7223

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7225
    bool another_turn; // line 7226
    u2 other_player; // line 7227
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 7228
    
    // sample a choice from the priori // line 7230
    query action_priori(current_player, row_choice, column_choice); // line 7231
    
    // is there a final_winner or is the grid filled? // line 7233
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 7234
    winning_condition(); // line 7235

    // if nobody has won and there is another turn to play... // line 7237
    if (final_winner == 0u2 && another_turn) {     // line 7238
        // passing the turn // line 7239
        if (current_player == 1u2) { // line 7240
            other_player = 2u2; // line 7241
        } else { // line 7242
            other_player = 1u2; // line 7243
        } // line 7244
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 7245

    } else {} // line 7247

    // observing according to the utility of the outcome // line 7249
    expected_utility(current_player); // line 7250

    // returning row_choice and column_choice - the choice of the player // line 7252
} // line 7253


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7256
    u2 sampled_row_choice, sampled_column_choice; // line 7257

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7259
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7260

    // observe that the choice is feasible, and update the grid // line 7262
    if (sampled_row_choice == 0u2) { // line 7263
        observe upper[sampled_column_choice] == 0u2; // line 7264
        upper[sampled_column_choice] = current_player; // line 7265
    } else { // line 7266
        if (sampled_row_choice == 1u2) { // line 7267
            observe middle[sampled_column_choice] == 0u2; // line 7268
            middle[sampled_column_choice] = current_player; // line 7269
        } else { // line 7270
            observe lower[sampled_column_choice] == 0u2; // line 7271
            lower[sampled_column_choice] = current_player; // line 7272
        } // line 7273
    } // line 7274
    row_choice = sampled_row_choice; // line 7275
    column_choice = sampled_column_choice; // line 7276
} // line 7277

expected_utility(u2 current_player) { // line 7279
    bool coin_flip; // line 7280
    u4 utility; // line 7281

    if (final_winner == current_player) { // line 7283
        utility = 10u4; // line 7284
    } else { // line 7285
        if (final_winner == 0u2) { // line 7286
        utility = 5u4; // line 7287
        } else { // line 7288
            utility = 1u4; // line 7289
        } // line 7290
    } // line 7291

    // outcome should range from 0 to 10 // line 7293
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7294
    observe coin_flip; // line 7295
} // line 7296

winning_condition() { // line 7298
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 7299
        final_winner = upper[0u2]; // line 7300
    } else { // line 7301
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 7302
            final_winner = middle[0u2]; // line 7303
        } else { // line 7304
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 7305
                final_winner = lower[0u2]; // line 7306
            } else { // line 7307
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 7308
                    final_winner = upper[0u2]; // line 7309
                } else { // line 7310
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 7311
                        final_winner = upper[1u2]; // line 7312
                    } else { // line 7313
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 7314
                            final_winner = upper[2u2]; // line 7315
                        } else { // line 7316
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 7317
                                final_winner = upper[0u2]; // line 7318
                            } else { // line 7319
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 7320
                                    final_winner = upper[2u2]; // line 7321
                                } else { // line 7322
                                    final_winner = 0u2; // line 7323
                                } // line 7324
                            } // line 7325
                        } // line 7326
                    } // line 7327
                } // line 7328
            } // line 7329
        } // line 7330
    } // line 7331
} // line 7332
u2[3] upper; // line 7333
u2[3] middle; // line 7334
u2[3] lower; // line 7335
u2 final_winner; // line 7336

/*   // line 7338
    0 = non assigned // line 7339
    1 = circle (player 1) // line 7340
    2 = cross (player 2) // line 7341
    Initial Condition:  // line 7342
    |   | O |   | // line 7343
    | O | X | X | // line 7344
    |   | O |   | // line 7345
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 7346
*/  // line 7347

main (){ // line 7349
    u2 row_choice, column_choice; // line 7350
    upper[0u2] = 0u2; // line 7351
	upper[1u2] = 1u2; // line 7352
	upper[2u2] = 0u2; // line 7353
    middle[0u2] = 1u2; // line 7354
	middle[1u2] = 2u2; // line 7355
	middle[2u2] = 2u2; // line 7356
    lower[0u2] = 0u2; // line 7357
	lower[1u2] = 1u2; // line 7358
	lower[2u2] = 0u2; // line 7359

    final_winner = 0u2; // line 7361
    query sampleAction(2u2, row_choice, column_choice); // line 7362

} // line 7364

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7366
    bool another_turn; // line 7367
    u2 other_player; // line 7368
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 7369
    
    // sample a choice from the priori // line 7371
    query action_priori(current_player, row_choice, column_choice); // line 7372
    
    // is there a final_winner or is the grid filled? // line 7374
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 7375
    winning_condition(); // line 7376

    // if nobody has won and there is another turn to play... // line 7378
    if (final_winner == 0u2 && another_turn) {     // line 7379
        // passing the turn // line 7380
        if (current_player == 1u2) { // line 7381
            other_player = 2u2; // line 7382
        } else { // line 7383
            other_player = 1u2; // line 7384
        } // line 7385
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 7386

    } else {} // line 7388

    // observing according to the utility of the outcome // line 7390
    expected_utility(current_player); // line 7391

    // returning row_choice and column_choice - the choice of the player // line 7393
} // line 7394


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7397
    u2 sampled_row_choice, sampled_column_choice; // line 7398

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7400
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7401

    // observe that the choice is feasible, and update the grid // line 7403
    if (sampled_row_choice == 0u2) { // line 7404
        observe upper[sampled_column_choice] == 0u2; // line 7405
        upper[sampled_column_choice] = current_player; // line 7406
    } else { // line 7407
        if (sampled_row_choice == 1u2) { // line 7408
            observe middle[sampled_column_choice] == 0u2; // line 7409
            middle[sampled_column_choice] = current_player; // line 7410
        } else { // line 7411
            observe lower[sampled_column_choice] == 0u2; // line 7412
            lower[sampled_column_choice] = current_player; // line 7413
        } // line 7414
    } // line 7415
    row_choice = sampled_row_choice; // line 7416
    column_choice = sampled_column_choice; // line 7417
} // line 7418

expected_utility(u2 current_player) { // line 7420
    bool coin_flip; // line 7421
    u4 utility; // line 7422

    if (final_winner == current_player) { // line 7424
        utility = 10u4; // line 7425
    } else { // line 7426
        if (final_winner == 0u2) { // line 7427
        utility = 5u4; // line 7428
        } else { // line 7429
            utility = 1u4; // line 7430
        } // line 7431
    } // line 7432

    // outcome should range from 0 to 10 // line 7434
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7435
    observe coin_flip; // line 7436
} // line 7437

winning_condition() { // line 7439
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 7440
        final_winner = upper[0u2]; // line 7441
    } else { // line 7442
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 7443
            final_winner = middle[0u2]; // line 7444
        } else { // line 7445
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 7446
                final_winner = lower[0u2]; // line 7447
            } else { // line 7448
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 7449
                    final_winner = upper[0u2]; // line 7450
                } else { // line 7451
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 7452
                        final_winner = upper[1u2]; // line 7453
                    } else { // line 7454
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 7455
                            final_winner = upper[2u2]; // line 7456
                        } else { // line 7457
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 7458
                                final_winner = upper[0u2]; // line 7459
                            } else { // line 7460
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 7461
                                    final_winner = upper[2u2]; // line 7462
                                } else { // line 7463
                                    final_winner = 0u2; // line 7464
                                } // line 7465
                            } // line 7466
                        } // line 7467
                    } // line 7468
                } // line 7469
            } // line 7470
        } // line 7471
    } // line 7472
} // line 7473
u2[3] upper; // line 7474
u2[3] middle; // line 7475
u2[3] lower; // line 7476
u2 final_winner; // line 7477

/*   // line 7479
    0 = non assigned // line 7480
    1 = circle (player 1) // line 7481
    2 = cross (player 2) // line 7482
    Initial Condition:  // line 7483
    |   | O |   | // line 7484
    | O | X | X | // line 7485
    |   | O |   | // line 7486
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 7487
*/  // line 7488

main (){ // line 7490
    u2 row_choice, column_choice; // line 7491
    upper[0u2] = 0u2; // line 7492
	upper[1u2] = 1u2; // line 7493
	upper[2u2] = 0u2; // line 7494
    middle[0u2] = 1u2; // line 7495
	middle[1u2] = 2u2; // line 7496
	middle[2u2] = 2u2; // line 7497
    lower[0u2] = 0u2; // line 7498
	lower[1u2] = 1u2; // line 7499
	lower[2u2] = 0u2; // line 7500

    final_winner = 0u2; // line 7502
    query sampleAction(2u2, row_choice, column_choice); // line 7503

} // line 7505

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7507
    bool another_turn; // line 7508
    u2 other_player; // line 7509
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 7510
    
    // sample a choice from the priori // line 7512
    query action_priori(current_player, row_choice, column_choice); // line 7513
    
    // is there a final_winner or is the grid filled? // line 7515
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 7516
    winning_condition(); // line 7517

    // if nobody has won and there is another turn to play... // line 7519
    if (final_winner == 0u2 && another_turn) {     // line 7520
        // passing the turn // line 7521
        if (current_player == 1u2) { // line 7522
            other_player = 2u2; // line 7523
        } else { // line 7524
            other_player = 1u2; // line 7525
        } // line 7526
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 7527

    } else {} // line 7529

    // observing according to the utility of the outcome // line 7531
    expected_utility(current_player); // line 7532

    // returning row_choice and column_choice - the choice of the player // line 7534
} // line 7535


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7538
    u2 sampled_row_choice, sampled_column_choice; // line 7539

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7541
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7542

    // observe that the choice is feasible, and update the grid // line 7544
    if (sampled_row_choice == 0u2) { // line 7545
        observe upper[sampled_column_choice] == 0u2; // line 7546
        upper[sampled_column_choice] = current_player; // line 7547
    } else { // line 7548
        if (sampled_row_choice == 1u2) { // line 7549
            observe middle[sampled_column_choice] == 0u2; // line 7550
            middle[sampled_column_choice] = current_player; // line 7551
        } else { // line 7552
            observe lower[sampled_column_choice] == 0u2; // line 7553
            lower[sampled_column_choice] = current_player; // line 7554
        } // line 7555
    } // line 7556
    row_choice = sampled_row_choice; // line 7557
    column_choice = sampled_column_choice; // line 7558
} // line 7559

expected_utility(u2 current_player) { // line 7561
    bool coin_flip; // line 7562
    u4 utility; // line 7563

    if (final_winner == current_player) { // line 7565
        utility = 10u4; // line 7566
    } else { // line 7567
        if (final_winner == 0u2) { // line 7568
        utility = 5u4; // line 7569
        } else { // line 7570
            utility = 1u4; // line 7571
        } // line 7572
    } // line 7573

    // outcome should range from 0 to 10 // line 7575
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7576
    observe coin_flip; // line 7577
} // line 7578

winning_condition() { // line 7580
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 7581
        final_winner = upper[0u2]; // line 7582
    } else { // line 7583
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 7584
            final_winner = middle[0u2]; // line 7585
        } else { // line 7586
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 7587
                final_winner = lower[0u2]; // line 7588
            } else { // line 7589
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 7590
                    final_winner = upper[0u2]; // line 7591
                } else { // line 7592
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 7593
                        final_winner = upper[1u2]; // line 7594
                    } else { // line 7595
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 7596
                            final_winner = upper[2u2]; // line 7597
                        } else { // line 7598
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 7599
                                final_winner = upper[0u2]; // line 7600
                            } else { // line 7601
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 7602
                                    final_winner = upper[2u2]; // line 7603
                                } else { // line 7604
                                    final_winner = 0u2; // line 7605
                                } // line 7606
                            } // line 7607
                        } // line 7608
                    } // line 7609
                } // line 7610
            } // line 7611
        } // line 7612
    } // line 7613
} // line 7614
u2[3] upper; // line 7615
u2[3] middle; // line 7616
u2[3] lower; // line 7617
u2 final_winner; // line 7618

/*   // line 7620
    0 = non assigned // line 7621
    1 = circle (player 1) // line 7622
    2 = cross (player 2) // line 7623
    Initial Condition:  // line 7624
    |   | O |   | // line 7625
    | O | X | X | // line 7626
    |   | O |   | // line 7627
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 7628
*/  // line 7629

main (){ // line 7631
    u2 row_choice, column_choice; // line 7632
    upper[0u2] = 0u2; // line 7633
	upper[1u2] = 1u2; // line 7634
	upper[2u2] = 0u2; // line 7635
    middle[0u2] = 1u2; // line 7636
	middle[1u2] = 2u2; // line 7637
	middle[2u2] = 2u2; // line 7638
    lower[0u2] = 0u2; // line 7639
	lower[1u2] = 1u2; // line 7640
	lower[2u2] = 0u2; // line 7641

    final_winner = 0u2; // line 7643
    query sampleAction(2u2, row_choice, column_choice); // line 7644

} // line 7646

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7648
    bool another_turn; // line 7649
    u2 other_player; // line 7650
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 7651
    
    // sample a choice from the priori // line 7653
    query action_priori(current_player, row_choice, column_choice); // line 7654
    
    // is there a final_winner or is the grid filled? // line 7656
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 7657
    winning_condition(); // line 7658

    // if nobody has won and there is another turn to play... // line 7660
    if (final_winner == 0u2 && another_turn) {     // line 7661
        // passing the turn // line 7662
        if (current_player == 1u2) { // line 7663
            other_player = 2u2; // line 7664
        } else { // line 7665
            other_player = 1u2; // line 7666
        } // line 7667
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 7668

    } else {} // line 7670

    // observing according to the utility of the outcome // line 7672
    expected_utility(current_player); // line 7673

    // returning row_choice and column_choice - the choice of the player // line 7675
} // line 7676


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7679
    u2 sampled_row_choice, sampled_column_choice; // line 7680

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7682
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7683

    // observe that the choice is feasible, and update the grid // line 7685
    if (sampled_row_choice == 0u2) { // line 7686
        observe upper[sampled_column_choice] == 0u2; // line 7687
        upper[sampled_column_choice] = current_player; // line 7688
    } else { // line 7689
        if (sampled_row_choice == 1u2) { // line 7690
            observe middle[sampled_column_choice] == 0u2; // line 7691
            middle[sampled_column_choice] = current_player; // line 7692
        } else { // line 7693
            observe lower[sampled_column_choice] == 0u2; // line 7694
            lower[sampled_column_choice] = current_player; // line 7695
        } // line 7696
    } // line 7697
    row_choice = sampled_row_choice; // line 7698
    column_choice = sampled_column_choice; // line 7699
} // line 7700

expected_utility(u2 current_player) { // line 7702
    bool coin_flip; // line 7703
    u4 utility; // line 7704

    if (final_winner == current_player) { // line 7706
        utility = 10u4; // line 7707
    } else { // line 7708
        if (final_winner == 0u2) { // line 7709
        utility = 5u4; // line 7710
        } else { // line 7711
            utility = 1u4; // line 7712
        } // line 7713
    } // line 7714

    // outcome should range from 0 to 10 // line 7716
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7717
    observe coin_flip; // line 7718
} // line 7719

winning_condition() { // line 7721
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 7722
        final_winner = upper[0u2]; // line 7723
    } else { // line 7724
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 7725
            final_winner = middle[0u2]; // line 7726
        } else { // line 7727
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 7728
                final_winner = lower[0u2]; // line 7729
            } else { // line 7730
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 7731
                    final_winner = upper[0u2]; // line 7732
                } else { // line 7733
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 7734
                        final_winner = upper[1u2]; // line 7735
                    } else { // line 7736
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 7737
                            final_winner = upper[2u2]; // line 7738
                        } else { // line 7739
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 7740
                                final_winner = upper[0u2]; // line 7741
                            } else { // line 7742
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 7743
                                    final_winner = upper[2u2]; // line 7744
                                } else { // line 7745
                                    final_winner = 0u2; // line 7746
                                } // line 7747
                            } // line 7748
                        } // line 7749
                    } // line 7750
                } // line 7751
            } // line 7752
        } // line 7753
    } // line 7754
} // line 7755
u2[3] upper; // line 7756
u2[3] middle; // line 7757
u2[3] lower; // line 7758
u2 final_winner; // line 7759

/*   // line 7761
    0 = non assigned // line 7762
    1 = circle (player 1) // line 7763
    2 = cross (player 2) // line 7764
    Initial Condition:  // line 7765
    |   | O |   | // line 7766
    | O | X | X | // line 7767
    |   | O |   | // line 7768
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 7769
*/  // line 7770

main (){ // line 7772
    u2 row_choice, column_choice; // line 7773
    upper[0u2] = 0u2; // line 7774
	upper[1u2] = 1u2; // line 7775
	upper[2u2] = 0u2; // line 7776
    middle[0u2] = 1u2; // line 7777
	middle[1u2] = 2u2; // line 7778
	middle[2u2] = 2u2; // line 7779
    lower[0u2] = 0u2; // line 7780
	lower[1u2] = 1u2; // line 7781
	lower[2u2] = 0u2; // line 7782

    final_winner = 0u2; // line 7784
    query sampleAction(2u2, row_choice, column_choice); // line 7785

} // line 7787

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7789
    bool another_turn; // line 7790
    u2 other_player; // line 7791
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 7792
    
    // sample a choice from the priori // line 7794
    query action_priori(current_player, row_choice, column_choice); // line 7795
    
    // is there a final_winner or is the grid filled? // line 7797
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 7798
    winning_condition(); // line 7799

    // if nobody has won and there is another turn to play... // line 7801
    if (final_winner == 0u2 && another_turn) {     // line 7802
        // passing the turn // line 7803
        if (current_player == 1u2) { // line 7804
            other_player = 2u2; // line 7805
        } else { // line 7806
            other_player = 1u2; // line 7807
        } // line 7808
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 7809

    } else {} // line 7811

    // observing according to the utility of the outcome // line 7813
    expected_utility(current_player); // line 7814

    // returning row_choice and column_choice - the choice of the player // line 7816
} // line 7817


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7820
    u2 sampled_row_choice, sampled_column_choice; // line 7821

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7823
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7824

    // observe that the choice is feasible, and update the grid // line 7826
    if (sampled_row_choice == 0u2) { // line 7827
        observe upper[sampled_column_choice] == 0u2; // line 7828
        upper[sampled_column_choice] = current_player; // line 7829
    } else { // line 7830
        if (sampled_row_choice == 1u2) { // line 7831
            observe middle[sampled_column_choice] == 0u2; // line 7832
            middle[sampled_column_choice] = current_player; // line 7833
        } else { // line 7834
            observe lower[sampled_column_choice] == 0u2; // line 7835
            lower[sampled_column_choice] = current_player; // line 7836
        } // line 7837
    } // line 7838
    row_choice = sampled_row_choice; // line 7839
    column_choice = sampled_column_choice; // line 7840
} // line 7841

expected_utility(u2 current_player) { // line 7843
    bool coin_flip; // line 7844
    u4 utility; // line 7845

    if (final_winner == current_player) { // line 7847
        utility = 10u4; // line 7848
    } else { // line 7849
        if (final_winner == 0u2) { // line 7850
        utility = 5u4; // line 7851
        } else { // line 7852
            utility = 1u4; // line 7853
        } // line 7854
    } // line 7855

    // outcome should range from 0 to 10 // line 7857
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7858
    observe coin_flip; // line 7859
} // line 7860

winning_condition() { // line 7862
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 7863
        final_winner = upper[0u2]; // line 7864
    } else { // line 7865
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 7866
            final_winner = middle[0u2]; // line 7867
        } else { // line 7868
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 7869
                final_winner = lower[0u2]; // line 7870
            } else { // line 7871
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 7872
                    final_winner = upper[0u2]; // line 7873
                } else { // line 7874
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 7875
                        final_winner = upper[1u2]; // line 7876
                    } else { // line 7877
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 7878
                            final_winner = upper[2u2]; // line 7879
                        } else { // line 7880
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 7881
                                final_winner = upper[0u2]; // line 7882
                            } else { // line 7883
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 7884
                                    final_winner = upper[2u2]; // line 7885
                                } else { // line 7886
                                    final_winner = 0u2; // line 7887
                                } // line 7888
                            } // line 7889
                        } // line 7890
                    } // line 7891
                } // line 7892
            } // line 7893
        } // line 7894
    } // line 7895
} // line 7896
u2[3] upper; // line 7897
u2[3] middle; // line 7898
u2[3] lower; // line 7899
u2 final_winner; // line 7900

/*   // line 7902
    0 = non assigned // line 7903
    1 = circle (player 1) // line 7904
    2 = cross (player 2) // line 7905
    Initial Condition:  // line 7906
    |   | O |   | // line 7907
    | O | X | X | // line 7908
    |   | O |   | // line 7909
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 7910
*/  // line 7911

main (){ // line 7913
    u2 row_choice, column_choice; // line 7914
    upper[0u2] = 0u2; // line 7915
	upper[1u2] = 1u2; // line 7916
	upper[2u2] = 0u2; // line 7917
    middle[0u2] = 1u2; // line 7918
	middle[1u2] = 2u2; // line 7919
	middle[2u2] = 2u2; // line 7920
    lower[0u2] = 0u2; // line 7921
	lower[1u2] = 1u2; // line 7922
	lower[2u2] = 0u2; // line 7923

    final_winner = 0u2; // line 7925
    query sampleAction(2u2, row_choice, column_choice); // line 7926

} // line 7928

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7930
    bool another_turn; // line 7931
    u2 other_player; // line 7932
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 7933
    
    // sample a choice from the priori // line 7935
    query action_priori(current_player, row_choice, column_choice); // line 7936
    
    // is there a final_winner or is the grid filled? // line 7938
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 7939
    winning_condition(); // line 7940

    // if nobody has won and there is another turn to play... // line 7942
    if (final_winner == 0u2 && another_turn) {     // line 7943
        // passing the turn // line 7944
        if (current_player == 1u2) { // line 7945
            other_player = 2u2; // line 7946
        } else { // line 7947
            other_player = 1u2; // line 7948
        } // line 7949
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 7950

    } else {} // line 7952

    // observing according to the utility of the outcome // line 7954
    expected_utility(current_player); // line 7955

    // returning row_choice and column_choice - the choice of the player // line 7957
} // line 7958


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 7961
    u2 sampled_row_choice, sampled_column_choice; // line 7962

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7964
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 7965

    // observe that the choice is feasible, and update the grid // line 7967
    if (sampled_row_choice == 0u2) { // line 7968
        observe upper[sampled_column_choice] == 0u2; // line 7969
        upper[sampled_column_choice] = current_player; // line 7970
    } else { // line 7971
        if (sampled_row_choice == 1u2) { // line 7972
            observe middle[sampled_column_choice] == 0u2; // line 7973
            middle[sampled_column_choice] = current_player; // line 7974
        } else { // line 7975
            observe lower[sampled_column_choice] == 0u2; // line 7976
            lower[sampled_column_choice] = current_player; // line 7977
        } // line 7978
    } // line 7979
    row_choice = sampled_row_choice; // line 7980
    column_choice = sampled_column_choice; // line 7981
} // line 7982

expected_utility(u2 current_player) { // line 7984
    bool coin_flip; // line 7985
    u4 utility; // line 7986

    if (final_winner == current_player) { // line 7988
        utility = 10u4; // line 7989
    } else { // line 7990
        if (final_winner == 0u2) { // line 7991
        utility = 5u4; // line 7992
        } else { // line 7993
            utility = 1u4; // line 7994
        } // line 7995
    } // line 7996

    // outcome should range from 0 to 10 // line 7998
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 7999
    observe coin_flip; // line 8000
} // line 8001

winning_condition() { // line 8003
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8004
        final_winner = upper[0u2]; // line 8005
    } else { // line 8006
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8007
            final_winner = middle[0u2]; // line 8008
        } else { // line 8009
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8010
                final_winner = lower[0u2]; // line 8011
            } else { // line 8012
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 8013
                    final_winner = upper[0u2]; // line 8014
                } else { // line 8015
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 8016
                        final_winner = upper[1u2]; // line 8017
                    } else { // line 8018
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 8019
                            final_winner = upper[2u2]; // line 8020
                        } else { // line 8021
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 8022
                                final_winner = upper[0u2]; // line 8023
                            } else { // line 8024
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 8025
                                    final_winner = upper[2u2]; // line 8026
                                } else { // line 8027
                                    final_winner = 0u2; // line 8028
                                } // line 8029
                            } // line 8030
                        } // line 8031
                    } // line 8032
                } // line 8033
            } // line 8034
        } // line 8035
    } // line 8036
} // line 8037
u2[3] upper; // line 8038
u2[3] middle; // line 8039
u2[3] lower; // line 8040
u2 final_winner; // line 8041

/*   // line 8043
    0 = non assigned // line 8044
    1 = circle (player 1) // line 8045
    2 = cross (player 2) // line 8046
    Initial Condition:  // line 8047
    |   | O |   | // line 8048
    | O | X | X | // line 8049
    |   | O |   | // line 8050
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 8051
*/  // line 8052

main (){ // line 8054
    u2 row_choice, column_choice; // line 8055
    upper[0u2] = 0u2; // line 8056
	upper[1u2] = 1u2; // line 8057
	upper[2u2] = 0u2; // line 8058
    middle[0u2] = 1u2; // line 8059
	middle[1u2] = 2u2; // line 8060
	middle[2u2] = 2u2; // line 8061
    lower[0u2] = 0u2; // line 8062
	lower[1u2] = 1u2; // line 8063
	lower[2u2] = 0u2; // line 8064

    final_winner = 0u2; // line 8066
    query sampleAction(2u2, row_choice, column_choice); // line 8067

} // line 8069

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8071
    bool another_turn; // line 8072
    u2 other_player; // line 8073
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 8074
    
    // sample a choice from the priori // line 8076
    query action_priori(current_player, row_choice, column_choice); // line 8077
    
    // is there a final_winner or is the grid filled? // line 8079
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 8080
    winning_condition(); // line 8081

    // if nobody has won and there is another turn to play... // line 8083
    if (final_winner == 0u2 && another_turn) {     // line 8084
        // passing the turn // line 8085
        if (current_player == 1u2) { // line 8086
            other_player = 2u2; // line 8087
        } else { // line 8088
            other_player = 1u2; // line 8089
        } // line 8090
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 8091

    } else {} // line 8093

    // observing according to the utility of the outcome // line 8095
    expected_utility(current_player); // line 8096

    // returning row_choice and column_choice - the choice of the player // line 8098
} // line 8099


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8102
    u2 sampled_row_choice, sampled_column_choice; // line 8103

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8105
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8106

    // observe that the choice is feasible, and update the grid // line 8108
    if (sampled_row_choice == 0u2) { // line 8109
        observe upper[sampled_column_choice] == 0u2; // line 8110
        upper[sampled_column_choice] = current_player; // line 8111
    } else { // line 8112
        if (sampled_row_choice == 1u2) { // line 8113
            observe middle[sampled_column_choice] == 0u2; // line 8114
            middle[sampled_column_choice] = current_player; // line 8115
        } else { // line 8116
            observe lower[sampled_column_choice] == 0u2; // line 8117
            lower[sampled_column_choice] = current_player; // line 8118
        } // line 8119
    } // line 8120
    row_choice = sampled_row_choice; // line 8121
    column_choice = sampled_column_choice; // line 8122
} // line 8123

expected_utility(u2 current_player) { // line 8125
    bool coin_flip; // line 8126
    u4 utility; // line 8127

    if (final_winner == current_player) { // line 8129
        utility = 10u4; // line 8130
    } else { // line 8131
        if (final_winner == 0u2) { // line 8132
        utility = 5u4; // line 8133
        } else { // line 8134
            utility = 1u4; // line 8135
        } // line 8136
    } // line 8137

    // outcome should range from 0 to 10 // line 8139
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 8140
    observe coin_flip; // line 8141
} // line 8142

winning_condition() { // line 8144
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8145
        final_winner = upper[0u2]; // line 8146
    } else { // line 8147
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8148
            final_winner = middle[0u2]; // line 8149
        } else { // line 8150
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8151
                final_winner = lower[0u2]; // line 8152
            } else { // line 8153
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 8154
                    final_winner = upper[0u2]; // line 8155
                } else { // line 8156
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 8157
                        final_winner = upper[1u2]; // line 8158
                    } else { // line 8159
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 8160
                            final_winner = upper[2u2]; // line 8161
                        } else { // line 8162
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 8163
                                final_winner = upper[0u2]; // line 8164
                            } else { // line 8165
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 8166
                                    final_winner = upper[2u2]; // line 8167
                                } else { // line 8168
                                    final_winner = 0u2; // line 8169
                                } // line 8170
                            } // line 8171
                        } // line 8172
                    } // line 8173
                } // line 8174
            } // line 8175
        } // line 8176
    } // line 8177
} // line 8178
u2[3] upper; // line 8179
u2[3] middle; // line 8180
u2[3] lower; // line 8181
u2 final_winner; // line 8182

/*   // line 8184
    0 = non assigned // line 8185
    1 = circle (player 1) // line 8186
    2 = cross (player 2) // line 8187
    Initial Condition:  // line 8188
    |   | O |   | // line 8189
    | O | X | X | // line 8190
    |   | O |   | // line 8191
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 8192
*/  // line 8193

main (){ // line 8195
    u2 row_choice, column_choice; // line 8196
    upper[0u2] = 0u2; // line 8197
	upper[1u2] = 1u2; // line 8198
	upper[2u2] = 0u2; // line 8199
    middle[0u2] = 1u2; // line 8200
	middle[1u2] = 2u2; // line 8201
	middle[2u2] = 2u2; // line 8202
    lower[0u2] = 0u2; // line 8203
	lower[1u2] = 1u2; // line 8204
	lower[2u2] = 0u2; // line 8205

    final_winner = 0u2; // line 8207
    query sampleAction(2u2, row_choice, column_choice); // line 8208

} // line 8210

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8212
    bool another_turn; // line 8213
    u2 other_player; // line 8214
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 8215
    
    // sample a choice from the priori // line 8217
    query action_priori(current_player, row_choice, column_choice); // line 8218
    
    // is there a final_winner or is the grid filled? // line 8220
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 8221
    winning_condition(); // line 8222

    // if nobody has won and there is another turn to play... // line 8224
    if (final_winner == 0u2 && another_turn) {     // line 8225
        // passing the turn // line 8226
        if (current_player == 1u2) { // line 8227
            other_player = 2u2; // line 8228
        } else { // line 8229
            other_player = 1u2; // line 8230
        } // line 8231
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 8232

    } else {} // line 8234

    // observing according to the utility of the outcome // line 8236
    expected_utility(current_player); // line 8237

    // returning row_choice and column_choice - the choice of the player // line 8239
} // line 8240


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8243
    u2 sampled_row_choice, sampled_column_choice; // line 8244

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8246
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8247

    // observe that the choice is feasible, and update the grid // line 8249
    if (sampled_row_choice == 0u2) { // line 8250
        observe upper[sampled_column_choice] == 0u2; // line 8251
        upper[sampled_column_choice] = current_player; // line 8252
    } else { // line 8253
        if (sampled_row_choice == 1u2) { // line 8254
            observe middle[sampled_column_choice] == 0u2; // line 8255
            middle[sampled_column_choice] = current_player; // line 8256
        } else { // line 8257
            observe lower[sampled_column_choice] == 0u2; // line 8258
            lower[sampled_column_choice] = current_player; // line 8259
        } // line 8260
    } // line 8261
    row_choice = sampled_row_choice; // line 8262
    column_choice = sampled_column_choice; // line 8263
} // line 8264

expected_utility(u2 current_player) { // line 8266
    bool coin_flip; // line 8267
    u4 utility; // line 8268

    if (final_winner == current_player) { // line 8270
        utility = 10u4; // line 8271
    } else { // line 8272
        if (final_winner == 0u2) { // line 8273
        utility = 5u4; // line 8274
        } else { // line 8275
            utility = 1u4; // line 8276
        } // line 8277
    } // line 8278

    // outcome should range from 0 to 10 // line 8280
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 8281
    observe coin_flip; // line 8282
} // line 8283

winning_condition() { // line 8285
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8286
        final_winner = upper[0u2]; // line 8287
    } else { // line 8288
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8289
            final_winner = middle[0u2]; // line 8290
        } else { // line 8291
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8292
                final_winner = lower[0u2]; // line 8293
            } else { // line 8294
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 8295
                    final_winner = upper[0u2]; // line 8296
                } else { // line 8297
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 8298
                        final_winner = upper[1u2]; // line 8299
                    } else { // line 8300
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 8301
                            final_winner = upper[2u2]; // line 8302
                        } else { // line 8303
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 8304
                                final_winner = upper[0u2]; // line 8305
                            } else { // line 8306
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 8307
                                    final_winner = upper[2u2]; // line 8308
                                } else { // line 8309
                                    final_winner = 0u2; // line 8310
                                } // line 8311
                            } // line 8312
                        } // line 8313
                    } // line 8314
                } // line 8315
            } // line 8316
        } // line 8317
    } // line 8318
} // line 8319
u2[3] upper; // line 8320
u2[3] middle; // line 8321
u2[3] lower; // line 8322
u2 final_winner; // line 8323

/*   // line 8325
    0 = non assigned // line 8326
    1 = circle (player 1) // line 8327
    2 = cross (player 2) // line 8328
    Initial Condition:  // line 8329
    |   | O |   | // line 8330
    | O | X | X | // line 8331
    |   | O |   | // line 8332
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 8333
*/  // line 8334

main (){ // line 8336
    u2 row_choice, column_choice; // line 8337
    upper[0u2] = 0u2; // line 8338
	upper[1u2] = 1u2; // line 8339
	upper[2u2] = 0u2; // line 8340
    middle[0u2] = 1u2; // line 8341
	middle[1u2] = 2u2; // line 8342
	middle[2u2] = 2u2; // line 8343
    lower[0u2] = 0u2; // line 8344
	lower[1u2] = 1u2; // line 8345
	lower[2u2] = 0u2; // line 8346

    final_winner = 0u2; // line 8348
    query sampleAction(2u2, row_choice, column_choice); // line 8349

} // line 8351

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8353
    bool another_turn; // line 8354
    u2 other_player; // line 8355
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 8356
    
    // sample a choice from the priori // line 8358
    query action_priori(current_player, row_choice, column_choice); // line 8359
    
    // is there a final_winner or is the grid filled? // line 8361
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 8362
    winning_condition(); // line 8363

    // if nobody has won and there is another turn to play... // line 8365
    if (final_winner == 0u2 && another_turn) {     // line 8366
        // passing the turn // line 8367
        if (current_player == 1u2) { // line 8368
            other_player = 2u2; // line 8369
        } else { // line 8370
            other_player = 1u2; // line 8371
        } // line 8372
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 8373

    } else {} // line 8375

    // observing according to the utility of the outcome // line 8377
    expected_utility(current_player); // line 8378

    // returning row_choice and column_choice - the choice of the player // line 8380
} // line 8381


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8384
    u2 sampled_row_choice, sampled_column_choice; // line 8385

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8387
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8388

    // observe that the choice is feasible, and update the grid // line 8390
    if (sampled_row_choice == 0u2) { // line 8391
        observe upper[sampled_column_choice] == 0u2; // line 8392
        upper[sampled_column_choice] = current_player; // line 8393
    } else { // line 8394
        if (sampled_row_choice == 1u2) { // line 8395
            observe middle[sampled_column_choice] == 0u2; // line 8396
            middle[sampled_column_choice] = current_player; // line 8397
        } else { // line 8398
            observe lower[sampled_column_choice] == 0u2; // line 8399
            lower[sampled_column_choice] = current_player; // line 8400
        } // line 8401
    } // line 8402
    row_choice = sampled_row_choice; // line 8403
    column_choice = sampled_column_choice; // line 8404
} // line 8405

expected_utility(u2 current_player) { // line 8407
    bool coin_flip; // line 8408
    u4 utility; // line 8409

    if (final_winner == current_player) { // line 8411
        utility = 10u4; // line 8412
    } else { // line 8413
        if (final_winner == 0u2) { // line 8414
        utility = 5u4; // line 8415
        } else { // line 8416
            utility = 1u4; // line 8417
        } // line 8418
    } // line 8419

    // outcome should range from 0 to 10 // line 8421
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 8422
    observe coin_flip; // line 8423
} // line 8424

winning_condition() { // line 8426
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8427
        final_winner = upper[0u2]; // line 8428
    } else { // line 8429
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8430
            final_winner = middle[0u2]; // line 8431
        } else { // line 8432
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8433
                final_winner = lower[0u2]; // line 8434
            } else { // line 8435
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 8436
                    final_winner = upper[0u2]; // line 8437
                } else { // line 8438
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 8439
                        final_winner = upper[1u2]; // line 8440
                    } else { // line 8441
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 8442
                            final_winner = upper[2u2]; // line 8443
                        } else { // line 8444
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 8445
                                final_winner = upper[0u2]; // line 8446
                            } else { // line 8447
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 8448
                                    final_winner = upper[2u2]; // line 8449
                                } else { // line 8450
                                    final_winner = 0u2; // line 8451
                                } // line 8452
                            } // line 8453
                        } // line 8454
                    } // line 8455
                } // line 8456
            } // line 8457
        } // line 8458
    } // line 8459
} // line 8460
u2[3] upper; // line 8461
u2[3] middle; // line 8462
u2[3] lower; // line 8463
u2 final_winner; // line 8464

/*   // line 8466
    0 = non assigned // line 8467
    1 = circle (player 1) // line 8468
    2 = cross (player 2) // line 8469
    Initial Condition:  // line 8470
    |   | O |   | // line 8471
    | O | X | X | // line 8472
    |   | O |   | // line 8473
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 8474
*/  // line 8475

main (){ // line 8477
    u2 row_choice, column_choice; // line 8478
    upper[0u2] = 0u2; // line 8479
	upper[1u2] = 1u2; // line 8480
	upper[2u2] = 0u2; // line 8481
    middle[0u2] = 1u2; // line 8482
	middle[1u2] = 2u2; // line 8483
	middle[2u2] = 2u2; // line 8484
    lower[0u2] = 0u2; // line 8485
	lower[1u2] = 1u2; // line 8486
	lower[2u2] = 0u2; // line 8487

    final_winner = 0u2; // line 8489
    query sampleAction(2u2, row_choice, column_choice); // line 8490

} // line 8492

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8494
    bool another_turn; // line 8495
    u2 other_player; // line 8496
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 8497
    
    // sample a choice from the priori // line 8499
    query action_priori(current_player, row_choice, column_choice); // line 8500
    
    // is there a final_winner or is the grid filled? // line 8502
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 8503
    winning_condition(); // line 8504

    // if nobody has won and there is another turn to play... // line 8506
    if (final_winner == 0u2 && another_turn) {     // line 8507
        // passing the turn // line 8508
        if (current_player == 1u2) { // line 8509
            other_player = 2u2; // line 8510
        } else { // line 8511
            other_player = 1u2; // line 8512
        } // line 8513
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 8514

    } else {} // line 8516

    // observing according to the utility of the outcome // line 8518
    expected_utility(current_player); // line 8519

    // returning row_choice and column_choice - the choice of the player // line 8521
} // line 8522


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8525
    u2 sampled_row_choice, sampled_column_choice; // line 8526

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8528
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8529

    // observe that the choice is feasible, and update the grid // line 8531
    if (sampled_row_choice == 0u2) { // line 8532
        observe upper[sampled_column_choice] == 0u2; // line 8533
        upper[sampled_column_choice] = current_player; // line 8534
    } else { // line 8535
        if (sampled_row_choice == 1u2) { // line 8536
            observe middle[sampled_column_choice] == 0u2; // line 8537
            middle[sampled_column_choice] = current_player; // line 8538
        } else { // line 8539
            observe lower[sampled_column_choice] == 0u2; // line 8540
            lower[sampled_column_choice] = current_player; // line 8541
        } // line 8542
    } // line 8543
    row_choice = sampled_row_choice; // line 8544
    column_choice = sampled_column_choice; // line 8545
} // line 8546

expected_utility(u2 current_player) { // line 8548
    bool coin_flip; // line 8549
    u4 utility; // line 8550

    if (final_winner == current_player) { // line 8552
        utility = 10u4; // line 8553
    } else { // line 8554
        if (final_winner == 0u2) { // line 8555
        utility = 5u4; // line 8556
        } else { // line 8557
            utility = 1u4; // line 8558
        } // line 8559
    } // line 8560

    // outcome should range from 0 to 10 // line 8562
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 8563
    observe coin_flip; // line 8564
} // line 8565

winning_condition() { // line 8567
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8568
        final_winner = upper[0u2]; // line 8569
    } else { // line 8570
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8571
            final_winner = middle[0u2]; // line 8572
        } else { // line 8573
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8574
                final_winner = lower[0u2]; // line 8575
            } else { // line 8576
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 8577
                    final_winner = upper[0u2]; // line 8578
                } else { // line 8579
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 8580
                        final_winner = upper[1u2]; // line 8581
                    } else { // line 8582
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 8583
                            final_winner = upper[2u2]; // line 8584
                        } else { // line 8585
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 8586
                                final_winner = upper[0u2]; // line 8587
                            } else { // line 8588
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 8589
                                    final_winner = upper[2u2]; // line 8590
                                } else { // line 8591
                                    final_winner = 0u2; // line 8592
                                } // line 8593
                            } // line 8594
                        } // line 8595
                    } // line 8596
                } // line 8597
            } // line 8598
        } // line 8599
    } // line 8600
} // line 8601
u2[3] upper; // line 8602
u2[3] middle; // line 8603
u2[3] lower; // line 8604
u2 final_winner; // line 8605

/*   // line 8607
    0 = non assigned // line 8608
    1 = circle (player 1) // line 8609
    2 = cross (player 2) // line 8610
    Initial Condition:  // line 8611
    |   | O |   | // line 8612
    | O | X | X | // line 8613
    |   | O |   | // line 8614
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 8615
*/  // line 8616

main (){ // line 8618
    u2 row_choice, column_choice; // line 8619
    upper[0u2] = 0u2; // line 8620
	upper[1u2] = 1u2; // line 8621
	upper[2u2] = 0u2; // line 8622
    middle[0u2] = 1u2; // line 8623
	middle[1u2] = 2u2; // line 8624
	middle[2u2] = 2u2; // line 8625
    lower[0u2] = 0u2; // line 8626
	lower[1u2] = 1u2; // line 8627
	lower[2u2] = 0u2; // line 8628

    final_winner = 0u2; // line 8630
    query sampleAction(2u2, row_choice, column_choice); // line 8631

} // line 8633

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8635
    bool another_turn; // line 8636
    u2 other_player; // line 8637
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 8638
    
    // sample a choice from the priori // line 8640
    query action_priori(current_player, row_choice, column_choice); // line 8641
    
    // is there a final_winner or is the grid filled? // line 8643
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 8644
    winning_condition(); // line 8645

    // if nobody has won and there is another turn to play... // line 8647
    if (final_winner == 0u2 && another_turn) {     // line 8648
        // passing the turn // line 8649
        if (current_player == 1u2) { // line 8650
            other_player = 2u2; // line 8651
        } else { // line 8652
            other_player = 1u2; // line 8653
        } // line 8654
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 8655

    } else {} // line 8657

    // observing according to the utility of the outcome // line 8659
    expected_utility(current_player); // line 8660

    // returning row_choice and column_choice - the choice of the player // line 8662
} // line 8663


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8666
    u2 sampled_row_choice, sampled_column_choice; // line 8667

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8669
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8670

    // observe that the choice is feasible, and update the grid // line 8672
    if (sampled_row_choice == 0u2) { // line 8673
        observe upper[sampled_column_choice] == 0u2; // line 8674
        upper[sampled_column_choice] = current_player; // line 8675
    } else { // line 8676
        if (sampled_row_choice == 1u2) { // line 8677
            observe middle[sampled_column_choice] == 0u2; // line 8678
            middle[sampled_column_choice] = current_player; // line 8679
        } else { // line 8680
            observe lower[sampled_column_choice] == 0u2; // line 8681
            lower[sampled_column_choice] = current_player; // line 8682
        } // line 8683
    } // line 8684
    row_choice = sampled_row_choice; // line 8685
    column_choice = sampled_column_choice; // line 8686
} // line 8687

expected_utility(u2 current_player) { // line 8689
    bool coin_flip; // line 8690
    u4 utility; // line 8691

    if (final_winner == current_player) { // line 8693
        utility = 10u4; // line 8694
    } else { // line 8695
        if (final_winner == 0u2) { // line 8696
        utility = 5u4; // line 8697
        } else { // line 8698
            utility = 1u4; // line 8699
        } // line 8700
    } // line 8701

    // outcome should range from 0 to 10 // line 8703
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 8704
    observe coin_flip; // line 8705
} // line 8706

winning_condition() { // line 8708
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8709
        final_winner = upper[0u2]; // line 8710
    } else { // line 8711
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8712
            final_winner = middle[0u2]; // line 8713
        } else { // line 8714
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8715
                final_winner = lower[0u2]; // line 8716
            } else { // line 8717
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 8718
                    final_winner = upper[0u2]; // line 8719
                } else { // line 8720
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 8721
                        final_winner = upper[1u2]; // line 8722
                    } else { // line 8723
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 8724
                            final_winner = upper[2u2]; // line 8725
                        } else { // line 8726
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 8727
                                final_winner = upper[0u2]; // line 8728
                            } else { // line 8729
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 8730
                                    final_winner = upper[2u2]; // line 8731
                                } else { // line 8732
                                    final_winner = 0u2; // line 8733
                                } // line 8734
                            } // line 8735
                        } // line 8736
                    } // line 8737
                } // line 8738
            } // line 8739
        } // line 8740
    } // line 8741
} // line 8742
u2[3] upper; // line 8743
u2[3] middle; // line 8744
u2[3] lower; // line 8745
u2 final_winner; // line 8746

/*   // line 8748
    0 = non assigned // line 8749
    1 = circle (player 1) // line 8750
    2 = cross (player 2) // line 8751
    Initial Condition:  // line 8752
    |   | O |   | // line 8753
    | O | X | X | // line 8754
    |   | O |   | // line 8755
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 8756
*/  // line 8757

main (){ // line 8759
    u2 row_choice, column_choice; // line 8760
    upper[0u2] = 0u2; // line 8761
	upper[1u2] = 1u2; // line 8762
	upper[2u2] = 0u2; // line 8763
    middle[0u2] = 1u2; // line 8764
	middle[1u2] = 2u2; // line 8765
	middle[2u2] = 2u2; // line 8766
    lower[0u2] = 0u2; // line 8767
	lower[1u2] = 1u2; // line 8768
	lower[2u2] = 0u2; // line 8769

    final_winner = 0u2; // line 8771
    query sampleAction(2u2, row_choice, column_choice); // line 8772

} // line 8774

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8776
    bool another_turn; // line 8777
    u2 other_player; // line 8778
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 8779
    
    // sample a choice from the priori // line 8781
    query action_priori(current_player, row_choice, column_choice); // line 8782
    
    // is there a final_winner or is the grid filled? // line 8784
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 8785
    winning_condition(); // line 8786

    // if nobody has won and there is another turn to play... // line 8788
    if (final_winner == 0u2 && another_turn) {     // line 8789
        // passing the turn // line 8790
        if (current_player == 1u2) { // line 8791
            other_player = 2u2; // line 8792
        } else { // line 8793
            other_player = 1u2; // line 8794
        } // line 8795
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 8796

    } else {} // line 8798

    // observing according to the utility of the outcome // line 8800
    expected_utility(current_player); // line 8801

    // returning row_choice and column_choice - the choice of the player // line 8803
} // line 8804


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8807
    u2 sampled_row_choice, sampled_column_choice; // line 8808

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8810
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8811

    // observe that the choice is feasible, and update the grid // line 8813
    if (sampled_row_choice == 0u2) { // line 8814
        observe upper[sampled_column_choice] == 0u2; // line 8815
        upper[sampled_column_choice] = current_player; // line 8816
    } else { // line 8817
        if (sampled_row_choice == 1u2) { // line 8818
            observe middle[sampled_column_choice] == 0u2; // line 8819
            middle[sampled_column_choice] = current_player; // line 8820
        } else { // line 8821
            observe lower[sampled_column_choice] == 0u2; // line 8822
            lower[sampled_column_choice] = current_player; // line 8823
        } // line 8824
    } // line 8825
    row_choice = sampled_row_choice; // line 8826
    column_choice = sampled_column_choice; // line 8827
} // line 8828

expected_utility(u2 current_player) { // line 8830
    bool coin_flip; // line 8831
    u4 utility; // line 8832

    if (final_winner == current_player) { // line 8834
        utility = 10u4; // line 8835
    } else { // line 8836
        if (final_winner == 0u2) { // line 8837
        utility = 5u4; // line 8838
        } else { // line 8839
            utility = 1u4; // line 8840
        } // line 8841
    } // line 8842

    // outcome should range from 0 to 10 // line 8844
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 8845
    observe coin_flip; // line 8846
} // line 8847

winning_condition() { // line 8849
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8850
        final_winner = upper[0u2]; // line 8851
    } else { // line 8852
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8853
            final_winner = middle[0u2]; // line 8854
        } else { // line 8855
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8856
                final_winner = lower[0u2]; // line 8857
            } else { // line 8858
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 8859
                    final_winner = upper[0u2]; // line 8860
                } else { // line 8861
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 8862
                        final_winner = upper[1u2]; // line 8863
                    } else { // line 8864
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 8865
                            final_winner = upper[2u2]; // line 8866
                        } else { // line 8867
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 8868
                                final_winner = upper[0u2]; // line 8869
                            } else { // line 8870
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 8871
                                    final_winner = upper[2u2]; // line 8872
                                } else { // line 8873
                                    final_winner = 0u2; // line 8874
                                } // line 8875
                            } // line 8876
                        } // line 8877
                    } // line 8878
                } // line 8879
            } // line 8880
        } // line 8881
    } // line 8882
} // line 8883
u2[3] upper; // line 8884
u2[3] middle; // line 8885
u2[3] lower; // line 8886
u2 final_winner; // line 8887

/*   // line 8889
    0 = non assigned // line 8890
    1 = circle (player 1) // line 8891
    2 = cross (player 2) // line 8892
    Initial Condition:  // line 8893
    |   | O |   | // line 8894
    | O | X | X | // line 8895
    |   | O |   | // line 8896
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 8897
*/  // line 8898

main (){ // line 8900
    u2 row_choice, column_choice; // line 8901
    upper[0u2] = 0u2; // line 8902
	upper[1u2] = 1u2; // line 8903
	upper[2u2] = 0u2; // line 8904
    middle[0u2] = 1u2; // line 8905
	middle[1u2] = 2u2; // line 8906
	middle[2u2] = 2u2; // line 8907
    lower[0u2] = 0u2; // line 8908
	lower[1u2] = 1u2; // line 8909
	lower[2u2] = 0u2; // line 8910

    final_winner = 0u2; // line 8912
    query sampleAction(2u2, row_choice, column_choice); // line 8913

} // line 8915

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8917
    bool another_turn; // line 8918
    u2 other_player; // line 8919
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 8920
    
    // sample a choice from the priori // line 8922
    query action_priori(current_player, row_choice, column_choice); // line 8923
    
    // is there a final_winner or is the grid filled? // line 8925
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 8926
    winning_condition(); // line 8927

    // if nobody has won and there is another turn to play... // line 8929
    if (final_winner == 0u2 && another_turn) {     // line 8930
        // passing the turn // line 8931
        if (current_player == 1u2) { // line 8932
            other_player = 2u2; // line 8933
        } else { // line 8934
            other_player = 1u2; // line 8935
        } // line 8936
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 8937

    } else {} // line 8939

    // observing according to the utility of the outcome // line 8941
    expected_utility(current_player); // line 8942

    // returning row_choice and column_choice - the choice of the player // line 8944
} // line 8945


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 8948
    u2 sampled_row_choice, sampled_column_choice; // line 8949

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8951
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 8952

    // observe that the choice is feasible, and update the grid // line 8954
    if (sampled_row_choice == 0u2) { // line 8955
        observe upper[sampled_column_choice] == 0u2; // line 8956
        upper[sampled_column_choice] = current_player; // line 8957
    } else { // line 8958
        if (sampled_row_choice == 1u2) { // line 8959
            observe middle[sampled_column_choice] == 0u2; // line 8960
            middle[sampled_column_choice] = current_player; // line 8961
        } else { // line 8962
            observe lower[sampled_column_choice] == 0u2; // line 8963
            lower[sampled_column_choice] = current_player; // line 8964
        } // line 8965
    } // line 8966
    row_choice = sampled_row_choice; // line 8967
    column_choice = sampled_column_choice; // line 8968
} // line 8969

expected_utility(u2 current_player) { // line 8971
    bool coin_flip; // line 8972
    u4 utility; // line 8973

    if (final_winner == current_player) { // line 8975
        utility = 10u4; // line 8976
    } else { // line 8977
        if (final_winner == 0u2) { // line 8978
        utility = 5u4; // line 8979
        } else { // line 8980
            utility = 1u4; // line 8981
        } // line 8982
    } // line 8983

    // outcome should range from 0 to 10 // line 8985
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 8986
    observe coin_flip; // line 8987
} // line 8988

winning_condition() { // line 8990
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 8991
        final_winner = upper[0u2]; // line 8992
    } else { // line 8993
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 8994
            final_winner = middle[0u2]; // line 8995
        } else { // line 8996
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 8997
                final_winner = lower[0u2]; // line 8998
            } else { // line 8999
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 9000
                    final_winner = upper[0u2]; // line 9001
                } else { // line 9002
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 9003
                        final_winner = upper[1u2]; // line 9004
                    } else { // line 9005
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 9006
                            final_winner = upper[2u2]; // line 9007
                        } else { // line 9008
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 9009
                                final_winner = upper[0u2]; // line 9010
                            } else { // line 9011
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 9012
                                    final_winner = upper[2u2]; // line 9013
                                } else { // line 9014
                                    final_winner = 0u2; // line 9015
                                } // line 9016
                            } // line 9017
                        } // line 9018
                    } // line 9019
                } // line 9020
            } // line 9021
        } // line 9022
    } // line 9023
} // line 9024
u2[3] upper; // line 9025
u2[3] middle; // line 9026
u2[3] lower; // line 9027
u2 final_winner; // line 9028

/*   // line 9030
    0 = non assigned // line 9031
    1 = circle (player 1) // line 9032
    2 = cross (player 2) // line 9033
    Initial Condition:  // line 9034
    |   | O |   | // line 9035
    | O | X | X | // line 9036
    |   | O |   | // line 9037
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 9038
*/  // line 9039

main (){ // line 9041
    u2 row_choice, column_choice; // line 9042
    upper[0u2] = 0u2; // line 9043
	upper[1u2] = 1u2; // line 9044
	upper[2u2] = 0u2; // line 9045
    middle[0u2] = 1u2; // line 9046
	middle[1u2] = 2u2; // line 9047
	middle[2u2] = 2u2; // line 9048
    lower[0u2] = 0u2; // line 9049
	lower[1u2] = 1u2; // line 9050
	lower[2u2] = 0u2; // line 9051

    final_winner = 0u2; // line 9053
    query sampleAction(2u2, row_choice, column_choice); // line 9054

} // line 9056

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9058
    bool another_turn; // line 9059
    u2 other_player; // line 9060
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 9061
    
    // sample a choice from the priori // line 9063
    query action_priori(current_player, row_choice, column_choice); // line 9064
    
    // is there a final_winner or is the grid filled? // line 9066
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 9067
    winning_condition(); // line 9068

    // if nobody has won and there is another turn to play... // line 9070
    if (final_winner == 0u2 && another_turn) {     // line 9071
        // passing the turn // line 9072
        if (current_player == 1u2) { // line 9073
            other_player = 2u2; // line 9074
        } else { // line 9075
            other_player = 1u2; // line 9076
        } // line 9077
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 9078

    } else {} // line 9080

    // observing according to the utility of the outcome // line 9082
    expected_utility(current_player); // line 9083

    // returning row_choice and column_choice - the choice of the player // line 9085
} // line 9086


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9089
    u2 sampled_row_choice, sampled_column_choice; // line 9090

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9092
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9093

    // observe that the choice is feasible, and update the grid // line 9095
    if (sampled_row_choice == 0u2) { // line 9096
        observe upper[sampled_column_choice] == 0u2; // line 9097
        upper[sampled_column_choice] = current_player; // line 9098
    } else { // line 9099
        if (sampled_row_choice == 1u2) { // line 9100
            observe middle[sampled_column_choice] == 0u2; // line 9101
            middle[sampled_column_choice] = current_player; // line 9102
        } else { // line 9103
            observe lower[sampled_column_choice] == 0u2; // line 9104
            lower[sampled_column_choice] = current_player; // line 9105
        } // line 9106
    } // line 9107
    row_choice = sampled_row_choice; // line 9108
    column_choice = sampled_column_choice; // line 9109
} // line 9110

expected_utility(u2 current_player) { // line 9112
    bool coin_flip; // line 9113
    u4 utility; // line 9114

    if (final_winner == current_player) { // line 9116
        utility = 10u4; // line 9117
    } else { // line 9118
        if (final_winner == 0u2) { // line 9119
        utility = 5u4; // line 9120
        } else { // line 9121
            utility = 1u4; // line 9122
        } // line 9123
    } // line 9124

    // outcome should range from 0 to 10 // line 9126
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 9127
    observe coin_flip; // line 9128
} // line 9129

winning_condition() { // line 9131
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 9132
        final_winner = upper[0u2]; // line 9133
    } else { // line 9134
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 9135
            final_winner = middle[0u2]; // line 9136
        } else { // line 9137
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 9138
                final_winner = lower[0u2]; // line 9139
            } else { // line 9140
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 9141
                    final_winner = upper[0u2]; // line 9142
                } else { // line 9143
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 9144
                        final_winner = upper[1u2]; // line 9145
                    } else { // line 9146
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 9147
                            final_winner = upper[2u2]; // line 9148
                        } else { // line 9149
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 9150
                                final_winner = upper[0u2]; // line 9151
                            } else { // line 9152
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 9153
                                    final_winner = upper[2u2]; // line 9154
                                } else { // line 9155
                                    final_winner = 0u2; // line 9156
                                } // line 9157
                            } // line 9158
                        } // line 9159
                    } // line 9160
                } // line 9161
            } // line 9162
        } // line 9163
    } // line 9164
} // line 9165
u2[3] upper; // line 9166
u2[3] middle; // line 9167
u2[3] lower; // line 9168
u2 final_winner; // line 9169

/*   // line 9171
    0 = non assigned // line 9172
    1 = circle (player 1) // line 9173
    2 = cross (player 2) // line 9174
    Initial Condition:  // line 9175
    |   | O |   | // line 9176
    | O | X | X | // line 9177
    |   | O |   | // line 9178
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 9179
*/  // line 9180

main (){ // line 9182
    u2 row_choice, column_choice; // line 9183
    upper[0u2] = 0u2; // line 9184
	upper[1u2] = 1u2; // line 9185
	upper[2u2] = 0u2; // line 9186
    middle[0u2] = 1u2; // line 9187
	middle[1u2] = 2u2; // line 9188
	middle[2u2] = 2u2; // line 9189
    lower[0u2] = 0u2; // line 9190
	lower[1u2] = 1u2; // line 9191
	lower[2u2] = 0u2; // line 9192

    final_winner = 0u2; // line 9194
    query sampleAction(2u2, row_choice, column_choice); // line 9195

} // line 9197

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9199
    bool another_turn; // line 9200
    u2 other_player; // line 9201
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 9202
    
    // sample a choice from the priori // line 9204
    query action_priori(current_player, row_choice, column_choice); // line 9205
    
    // is there a final_winner or is the grid filled? // line 9207
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 9208
    winning_condition(); // line 9209

    // if nobody has won and there is another turn to play... // line 9211
    if (final_winner == 0u2 && another_turn) {     // line 9212
        // passing the turn // line 9213
        if (current_player == 1u2) { // line 9214
            other_player = 2u2; // line 9215
        } else { // line 9216
            other_player = 1u2; // line 9217
        } // line 9218
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 9219

    } else {} // line 9221

    // observing according to the utility of the outcome // line 9223
    expected_utility(current_player); // line 9224

    // returning row_choice and column_choice - the choice of the player // line 9226
} // line 9227


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9230
    u2 sampled_row_choice, sampled_column_choice; // line 9231

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9233
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9234

    // observe that the choice is feasible, and update the grid // line 9236
    if (sampled_row_choice == 0u2) { // line 9237
        observe upper[sampled_column_choice] == 0u2; // line 9238
        upper[sampled_column_choice] = current_player; // line 9239
    } else { // line 9240
        if (sampled_row_choice == 1u2) { // line 9241
            observe middle[sampled_column_choice] == 0u2; // line 9242
            middle[sampled_column_choice] = current_player; // line 9243
        } else { // line 9244
            observe lower[sampled_column_choice] == 0u2; // line 9245
            lower[sampled_column_choice] = current_player; // line 9246
        } // line 9247
    } // line 9248
    row_choice = sampled_row_choice; // line 9249
    column_choice = sampled_column_choice; // line 9250
} // line 9251

expected_utility(u2 current_player) { // line 9253
    bool coin_flip; // line 9254
    u4 utility; // line 9255

    if (final_winner == current_player) { // line 9257
        utility = 10u4; // line 9258
    } else { // line 9259
        if (final_winner == 0u2) { // line 9260
        utility = 5u4; // line 9261
        } else { // line 9262
            utility = 1u4; // line 9263
        } // line 9264
    } // line 9265

    // outcome should range from 0 to 10 // line 9267
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 9268
    observe coin_flip; // line 9269
} // line 9270

winning_condition() { // line 9272
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 9273
        final_winner = upper[0u2]; // line 9274
    } else { // line 9275
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 9276
            final_winner = middle[0u2]; // line 9277
        } else { // line 9278
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 9279
                final_winner = lower[0u2]; // line 9280
            } else { // line 9281
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 9282
                    final_winner = upper[0u2]; // line 9283
                } else { // line 9284
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 9285
                        final_winner = upper[1u2]; // line 9286
                    } else { // line 9287
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 9288
                            final_winner = upper[2u2]; // line 9289
                        } else { // line 9290
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 9291
                                final_winner = upper[0u2]; // line 9292
                            } else { // line 9293
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 9294
                                    final_winner = upper[2u2]; // line 9295
                                } else { // line 9296
                                    final_winner = 0u2; // line 9297
                                } // line 9298
                            } // line 9299
                        } // line 9300
                    } // line 9301
                } // line 9302
            } // line 9303
        } // line 9304
    } // line 9305
} // line 9306
u2[3] upper; // line 9307
u2[3] middle; // line 9308
u2[3] lower; // line 9309
u2 final_winner; // line 9310

/*   // line 9312
    0 = non assigned // line 9313
    1 = circle (player 1) // line 9314
    2 = cross (player 2) // line 9315
    Initial Condition:  // line 9316
    |   | O |   | // line 9317
    | O | X | X | // line 9318
    |   | O |   | // line 9319
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 9320
*/  // line 9321

main (){ // line 9323
    u2 row_choice, column_choice; // line 9324
    upper[0u2] = 0u2; // line 9325
	upper[1u2] = 1u2; // line 9326
	upper[2u2] = 0u2; // line 9327
    middle[0u2] = 1u2; // line 9328
	middle[1u2] = 2u2; // line 9329
	middle[2u2] = 2u2; // line 9330
    lower[0u2] = 0u2; // line 9331
	lower[1u2] = 1u2; // line 9332
	lower[2u2] = 0u2; // line 9333

    final_winner = 0u2; // line 9335
    query sampleAction(2u2, row_choice, column_choice); // line 9336

} // line 9338

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9340
    bool another_turn; // line 9341
    u2 other_player; // line 9342
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 9343
    
    // sample a choice from the priori // line 9345
    query action_priori(current_player, row_choice, column_choice); // line 9346
    
    // is there a final_winner or is the grid filled? // line 9348
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 9349
    winning_condition(); // line 9350

    // if nobody has won and there is another turn to play... // line 9352
    if (final_winner == 0u2 && another_turn) {     // line 9353
        // passing the turn // line 9354
        if (current_player == 1u2) { // line 9355
            other_player = 2u2; // line 9356
        } else { // line 9357
            other_player = 1u2; // line 9358
        } // line 9359
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 9360

    } else {} // line 9362

    // observing according to the utility of the outcome // line 9364
    expected_utility(current_player); // line 9365

    // returning row_choice and column_choice - the choice of the player // line 9367
} // line 9368


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9371
    u2 sampled_row_choice, sampled_column_choice; // line 9372

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9374
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9375

    // observe that the choice is feasible, and update the grid // line 9377
    if (sampled_row_choice == 0u2) { // line 9378
        observe upper[sampled_column_choice] == 0u2; // line 9379
        upper[sampled_column_choice] = current_player; // line 9380
    } else { // line 9381
        if (sampled_row_choice == 1u2) { // line 9382
            observe middle[sampled_column_choice] == 0u2; // line 9383
            middle[sampled_column_choice] = current_player; // line 9384
        } else { // line 9385
            observe lower[sampled_column_choice] == 0u2; // line 9386
            lower[sampled_column_choice] = current_player; // line 9387
        } // line 9388
    } // line 9389
    row_choice = sampled_row_choice; // line 9390
    column_choice = sampled_column_choice; // line 9391
} // line 9392

expected_utility(u2 current_player) { // line 9394
    bool coin_flip; // line 9395
    u4 utility; // line 9396

    if (final_winner == current_player) { // line 9398
        utility = 10u4; // line 9399
    } else { // line 9400
        if (final_winner == 0u2) { // line 9401
        utility = 5u4; // line 9402
        } else { // line 9403
            utility = 1u4; // line 9404
        } // line 9405
    } // line 9406

    // outcome should range from 0 to 10 // line 9408
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 9409
    observe coin_flip; // line 9410
} // line 9411

winning_condition() { // line 9413
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 9414
        final_winner = upper[0u2]; // line 9415
    } else { // line 9416
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 9417
            final_winner = middle[0u2]; // line 9418
        } else { // line 9419
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 9420
                final_winner = lower[0u2]; // line 9421
            } else { // line 9422
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 9423
                    final_winner = upper[0u2]; // line 9424
                } else { // line 9425
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 9426
                        final_winner = upper[1u2]; // line 9427
                    } else { // line 9428
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 9429
                            final_winner = upper[2u2]; // line 9430
                        } else { // line 9431
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 9432
                                final_winner = upper[0u2]; // line 9433
                            } else { // line 9434
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 9435
                                    final_winner = upper[2u2]; // line 9436
                                } else { // line 9437
                                    final_winner = 0u2; // line 9438
                                } // line 9439
                            } // line 9440
                        } // line 9441
                    } // line 9442
                } // line 9443
            } // line 9444
        } // line 9445
    } // line 9446
} // line 9447
u2[3] upper; // line 9448
u2[3] middle; // line 9449
u2[3] lower; // line 9450
u2 final_winner; // line 9451

/*   // line 9453
    0 = non assigned // line 9454
    1 = circle (player 1) // line 9455
    2 = cross (player 2) // line 9456
    Initial Condition:  // line 9457
    |   | O |   | // line 9458
    | O | X | X | // line 9459
    |   | O |   | // line 9460
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 9461
*/  // line 9462

main (){ // line 9464
    u2 row_choice, column_choice; // line 9465
    upper[0u2] = 0u2; // line 9466
	upper[1u2] = 1u2; // line 9467
	upper[2u2] = 0u2; // line 9468
    middle[0u2] = 1u2; // line 9469
	middle[1u2] = 2u2; // line 9470
	middle[2u2] = 2u2; // line 9471
    lower[0u2] = 0u2; // line 9472
	lower[1u2] = 1u2; // line 9473
	lower[2u2] = 0u2; // line 9474

    final_winner = 0u2; // line 9476
    query sampleAction(2u2, row_choice, column_choice); // line 9477

} // line 9479

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9481
    bool another_turn; // line 9482
    u2 other_player; // line 9483
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 9484
    
    // sample a choice from the priori // line 9486
    query action_priori(current_player, row_choice, column_choice); // line 9487
    
    // is there a final_winner or is the grid filled? // line 9489
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 9490
    winning_condition(); // line 9491

    // if nobody has won and there is another turn to play... // line 9493
    if (final_winner == 0u2 && another_turn) {     // line 9494
        // passing the turn // line 9495
        if (current_player == 1u2) { // line 9496
            other_player = 2u2; // line 9497
        } else { // line 9498
            other_player = 1u2; // line 9499
        } // line 9500
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 9501

    } else {} // line 9503

    // observing according to the utility of the outcome // line 9505
    expected_utility(current_player); // line 9506

    // returning row_choice and column_choice - the choice of the player // line 9508
} // line 9509


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9512
    u2 sampled_row_choice, sampled_column_choice; // line 9513

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9515
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9516

    // observe that the choice is feasible, and update the grid // line 9518
    if (sampled_row_choice == 0u2) { // line 9519
        observe upper[sampled_column_choice] == 0u2; // line 9520
        upper[sampled_column_choice] = current_player; // line 9521
    } else { // line 9522
        if (sampled_row_choice == 1u2) { // line 9523
            observe middle[sampled_column_choice] == 0u2; // line 9524
            middle[sampled_column_choice] = current_player; // line 9525
        } else { // line 9526
            observe lower[sampled_column_choice] == 0u2; // line 9527
            lower[sampled_column_choice] = current_player; // line 9528
        } // line 9529
    } // line 9530
    row_choice = sampled_row_choice; // line 9531
    column_choice = sampled_column_choice; // line 9532
} // line 9533

expected_utility(u2 current_player) { // line 9535
    bool coin_flip; // line 9536
    u4 utility; // line 9537

    if (final_winner == current_player) { // line 9539
        utility = 10u4; // line 9540
    } else { // line 9541
        if (final_winner == 0u2) { // line 9542
        utility = 5u4; // line 9543
        } else { // line 9544
            utility = 1u4; // line 9545
        } // line 9546
    } // line 9547

    // outcome should range from 0 to 10 // line 9549
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 9550
    observe coin_flip; // line 9551
} // line 9552

winning_condition() { // line 9554
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 9555
        final_winner = upper[0u2]; // line 9556
    } else { // line 9557
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 9558
            final_winner = middle[0u2]; // line 9559
        } else { // line 9560
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 9561
                final_winner = lower[0u2]; // line 9562
            } else { // line 9563
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 9564
                    final_winner = upper[0u2]; // line 9565
                } else { // line 9566
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 9567
                        final_winner = upper[1u2]; // line 9568
                    } else { // line 9569
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 9570
                            final_winner = upper[2u2]; // line 9571
                        } else { // line 9572
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 9573
                                final_winner = upper[0u2]; // line 9574
                            } else { // line 9575
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 9576
                                    final_winner = upper[2u2]; // line 9577
                                } else { // line 9578
                                    final_winner = 0u2; // line 9579
                                } // line 9580
                            } // line 9581
                        } // line 9582
                    } // line 9583
                } // line 9584
            } // line 9585
        } // line 9586
    } // line 9587
} // line 9588
u2[3] upper; // line 9589
u2[3] middle; // line 9590
u2[3] lower; // line 9591
u2 final_winner; // line 9592

/*   // line 9594
    0 = non assigned // line 9595
    1 = circle (player 1) // line 9596
    2 = cross (player 2) // line 9597
    Initial Condition:  // line 9598
    |   | O |   | // line 9599
    | O | X | X | // line 9600
    |   | O |   | // line 9601
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 9602
*/  // line 9603

main (){ // line 9605
    u2 row_choice, column_choice; // line 9606
    upper[0u2] = 0u2; // line 9607
	upper[1u2] = 1u2; // line 9608
	upper[2u2] = 0u2; // line 9609
    middle[0u2] = 1u2; // line 9610
	middle[1u2] = 2u2; // line 9611
	middle[2u2] = 2u2; // line 9612
    lower[0u2] = 0u2; // line 9613
	lower[1u2] = 1u2; // line 9614
	lower[2u2] = 0u2; // line 9615

    final_winner = 0u2; // line 9617
    query sampleAction(2u2, row_choice, column_choice); // line 9618

} // line 9620

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9622
    bool another_turn; // line 9623
    u2 other_player; // line 9624
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 9625
    
    // sample a choice from the priori // line 9627
    query action_priori(current_player, row_choice, column_choice); // line 9628
    
    // is there a final_winner or is the grid filled? // line 9630
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 9631
    winning_condition(); // line 9632

    // if nobody has won and there is another turn to play... // line 9634
    if (final_winner == 0u2 && another_turn) {     // line 9635
        // passing the turn // line 9636
        if (current_player == 1u2) { // line 9637
            other_player = 2u2; // line 9638
        } else { // line 9639
            other_player = 1u2; // line 9640
        } // line 9641
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 9642

    } else {} // line 9644

    // observing according to the utility of the outcome // line 9646
    expected_utility(current_player); // line 9647

    // returning row_choice and column_choice - the choice of the player // line 9649
} // line 9650


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9653
    u2 sampled_row_choice, sampled_column_choice; // line 9654

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9656
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9657

    // observe that the choice is feasible, and update the grid // line 9659
    if (sampled_row_choice == 0u2) { // line 9660
        observe upper[sampled_column_choice] == 0u2; // line 9661
        upper[sampled_column_choice] = current_player; // line 9662
    } else { // line 9663
        if (sampled_row_choice == 1u2) { // line 9664
            observe middle[sampled_column_choice] == 0u2; // line 9665
            middle[sampled_column_choice] = current_player; // line 9666
        } else { // line 9667
            observe lower[sampled_column_choice] == 0u2; // line 9668
            lower[sampled_column_choice] = current_player; // line 9669
        } // line 9670
    } // line 9671
    row_choice = sampled_row_choice; // line 9672
    column_choice = sampled_column_choice; // line 9673
} // line 9674

expected_utility(u2 current_player) { // line 9676
    bool coin_flip; // line 9677
    u4 utility; // line 9678

    if (final_winner == current_player) { // line 9680
        utility = 10u4; // line 9681
    } else { // line 9682
        if (final_winner == 0u2) { // line 9683
        utility = 5u4; // line 9684
        } else { // line 9685
            utility = 1u4; // line 9686
        } // line 9687
    } // line 9688

    // outcome should range from 0 to 10 // line 9690
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 9691
    observe coin_flip; // line 9692
} // line 9693

winning_condition() { // line 9695
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 9696
        final_winner = upper[0u2]; // line 9697
    } else { // line 9698
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 9699
            final_winner = middle[0u2]; // line 9700
        } else { // line 9701
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 9702
                final_winner = lower[0u2]; // line 9703
            } else { // line 9704
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 9705
                    final_winner = upper[0u2]; // line 9706
                } else { // line 9707
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 9708
                        final_winner = upper[1u2]; // line 9709
                    } else { // line 9710
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 9711
                            final_winner = upper[2u2]; // line 9712
                        } else { // line 9713
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 9714
                                final_winner = upper[0u2]; // line 9715
                            } else { // line 9716
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 9717
                                    final_winner = upper[2u2]; // line 9718
                                } else { // line 9719
                                    final_winner = 0u2; // line 9720
                                } // line 9721
                            } // line 9722
                        } // line 9723
                    } // line 9724
                } // line 9725
            } // line 9726
        } // line 9727
    } // line 9728
} // line 9729
u2[3] upper; // line 9730
u2[3] middle; // line 9731
u2[3] lower; // line 9732
u2 final_winner; // line 9733

/*   // line 9735
    0 = non assigned // line 9736
    1 = circle (player 1) // line 9737
    2 = cross (player 2) // line 9738
    Initial Condition:  // line 9739
    |   | O |   | // line 9740
    | O | X | X | // line 9741
    |   | O |   | // line 9742
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 9743
*/  // line 9744

main (){ // line 9746
    u2 row_choice, column_choice; // line 9747
    upper[0u2] = 0u2; // line 9748
	upper[1u2] = 1u2; // line 9749
	upper[2u2] = 0u2; // line 9750
    middle[0u2] = 1u2; // line 9751
	middle[1u2] = 2u2; // line 9752
	middle[2u2] = 2u2; // line 9753
    lower[0u2] = 0u2; // line 9754
	lower[1u2] = 1u2; // line 9755
	lower[2u2] = 0u2; // line 9756

    final_winner = 0u2; // line 9758
    query sampleAction(2u2, row_choice, column_choice); // line 9759

} // line 9761

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9763
    bool another_turn; // line 9764
    u2 other_player; // line 9765
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 9766
    
    // sample a choice from the priori // line 9768
    query action_priori(current_player, row_choice, column_choice); // line 9769
    
    // is there a final_winner or is the grid filled? // line 9771
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 9772
    winning_condition(); // line 9773

    // if nobody has won and there is another turn to play... // line 9775
    if (final_winner == 0u2 && another_turn) {     // line 9776
        // passing the turn // line 9777
        if (current_player == 1u2) { // line 9778
            other_player = 2u2; // line 9779
        } else { // line 9780
            other_player = 1u2; // line 9781
        } // line 9782
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 9783

    } else {} // line 9785

    // observing according to the utility of the outcome // line 9787
    expected_utility(current_player); // line 9788

    // returning row_choice and column_choice - the choice of the player // line 9790
} // line 9791


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9794
    u2 sampled_row_choice, sampled_column_choice; // line 9795

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9797
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9798

    // observe that the choice is feasible, and update the grid // line 9800
    if (sampled_row_choice == 0u2) { // line 9801
        observe upper[sampled_column_choice] == 0u2; // line 9802
        upper[sampled_column_choice] = current_player; // line 9803
    } else { // line 9804
        if (sampled_row_choice == 1u2) { // line 9805
            observe middle[sampled_column_choice] == 0u2; // line 9806
            middle[sampled_column_choice] = current_player; // line 9807
        } else { // line 9808
            observe lower[sampled_column_choice] == 0u2; // line 9809
            lower[sampled_column_choice] = current_player; // line 9810
        } // line 9811
    } // line 9812
    row_choice = sampled_row_choice; // line 9813
    column_choice = sampled_column_choice; // line 9814
} // line 9815

expected_utility(u2 current_player) { // line 9817
    bool coin_flip; // line 9818
    u4 utility; // line 9819

    if (final_winner == current_player) { // line 9821
        utility = 10u4; // line 9822
    } else { // line 9823
        if (final_winner == 0u2) { // line 9824
        utility = 5u4; // line 9825
        } else { // line 9826
            utility = 1u4; // line 9827
        } // line 9828
    } // line 9829

    // outcome should range from 0 to 10 // line 9831
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 9832
    observe coin_flip; // line 9833
} // line 9834

winning_condition() { // line 9836
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) { // line 9837
        final_winner = upper[0u2]; // line 9838
    } else { // line 9839
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) { // line 9840
            final_winner = middle[0u2]; // line 9841
        } else { // line 9842
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) { // line 9843
                final_winner = lower[0u2]; // line 9844
            } else { // line 9845
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) { // line 9846
                    final_winner = upper[0u2]; // line 9847
                } else { // line 9848
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) { // line 9849
                        final_winner = upper[1u2]; // line 9850
                    } else { // line 9851
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) { // line 9852
                            final_winner = upper[2u2]; // line 9853
                        } else { // line 9854
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) { // line 9855
                                final_winner = upper[0u2]; // line 9856
                            } else { // line 9857
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) { // line 9858
                                    final_winner = upper[2u2]; // line 9859
                                } else { // line 9860
                                    final_winner = 0u2; // line 9861
                                } // line 9862
                            } // line 9863
                        } // line 9864
                    } // line 9865
                } // line 9866
            } // line 9867
        } // line 9868
    } // line 9869
} // line 9870
u2[3] upper; // line 9871
u2[3] middle; // line 9872
u2[3] lower; // line 9873
u2 final_winner; // line 9874

/*   // line 9876
    0 = non assigned // line 9877
    1 = circle (player 1) // line 9878
    2 = cross (player 2) // line 9879
    Initial Condition:  // line 9880
    |   | O |   | // line 9881
    | O | X | X | // line 9882
    |   | O |   | // line 9883
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014. // line 9884
*/  // line 9885

main (){ // line 9887
    u2 row_choice, column_choice; // line 9888
    upper[0u2] = 0u2; // line 9889
	upper[1u2] = 1u2; // line 9890
	upper[2u2] = 0u2; // line 9891
    middle[0u2] = 1u2; // line 9892
	middle[1u2] = 2u2; // line 9893
	middle[2u2] = 2u2; // line 9894
    lower[0u2] = 0u2; // line 9895
	lower[1u2] = 1u2; // line 9896
	lower[2u2] = 0u2; // line 9897

    final_winner = 0u2; // line 9899
    query sampleAction(2u2, row_choice, column_choice); // line 9900

} // line 9902

sampleAction(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9904
    bool another_turn; // line 9905
    u2 other_player; // line 9906
    u2 otherPlayerRowChoice, otherPlayerColumnChoice;  // line 9907
    
    // sample a choice from the priori // line 9909
    query action_priori(current_player, row_choice, column_choice); // line 9910
    
    // is there a final_winner or is the grid filled? // line 9912
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2; // line 9913
    winning_condition(); // line 9914

    // if nobody has won and there is another turn to play... // line 9916
    if (final_winner == 0u2 && another_turn) {     // line 9917
        // passing the turn // line 9918
        if (current_player == 1u2) { // line 9919
            other_player = 2u2; // line 9920
        } else { // line 9921
            other_player = 1u2; // line 9922
        } // line 9923
        query sampleAction(other_player, otherPlayerRowChoice, otherPlayerColumnChoice); // line 9924

    } else {} // line 9926

    // observing according to the utility of the outcome // line 9928
    expected_utility(current_player); // line 9929

    // returning row_choice and column_choice - the choice of the player // line 9931
} // line 9932


action_priori(u2 current_player, u2 &row_choice, u2 &column_choice) { // line 9935
    u2 sampled_row_choice, sampled_column_choice; // line 9936

    sampled_row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9938
    sampled_column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2; // line 9939

    // observe that the choice is feasible, and update the grid // line 9941
    if (sampled_row_choice == 0u2) { // line 9942
        observe upper[sampled_column_choice] == 0u2; // line 9943
        upper[sampled_column_choice] = current_player; // line 9944
    } else { // line 9945
        if (sampled_row_choice == 1u2) { // line 9946
            observe middle[sampled_column_choice] == 0u2; // line 9947
            middle[sampled_column_choice] = current_player; // line 9948
        } else { // line 9949
            observe lower[sampled_column_choice] == 0u2; // line 9950
            lower[sampled_column_choice] = current_player; // line 9951
        } // line 9952
    } // line 9953
    row_choice = sampled_row_choice; // line 9954
    column_choice = sampled_column_choice; // line 9955
} // line 9956

expected_utility(u2 current_player) { // line 9958
    bool coin_flip; // line 9959
    u4 utility; // line 9960

    if (final_winner == current_player) { // line 9962
        utility = 10u4; // line 9963
    } else { // line 9964
        if (final_winner == 0u2) { // line 9965
        utility = 5u4; // line 9966
        } else { // line 9967
            utility = 1u4; // line 9968
        } // line 9969
    } // line 9970

    // outcome should range from 0 to 10 // line 9972
    coin_flip = 1u1 {utility : 10u4} 0u1; // line 9973
    observe coin_flip; // line 9974
} // line 9975